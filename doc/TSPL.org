#+TITLE The Scheme Programming Language Learning Note
#+AUTHOR R. Kent Dybvig

* Preface(序言)
* 1. Introduction(引言)
** 1.Scheme Syntax(语法)
   Scheme programs _are make up of_ *keyworkd(关键字),variables(变量),structed 
forms(结构化形式), constant data(常量数据), whitespace(空白符) and comments注*
*释.)*
Keyword, variables and symbols are collectively(全体/共同地) called identifiers
关键字，变量和符号统称为标识符。
*** *标识符*
*Identifiers* maybe formed from letters, digits, and certain specifial characte
rsinclude ?!.+-*/<=>:$%^_!@, as well as a setof additionall unicode characeers.
标识符有字母，数字，某些特殊字符 和 Unicode字符。
Identifiers can not start with at sign(@) and normally cannot start with any ch
aracters that can start a number, i.e, a dibit, plus sign(+), minus sign(-), or
decimal point(.).
标识符不能以@,+,-,.开头
Eacheptions ares +, -, and ..., which are valid identifires.
+,-,... 是合法标识符。
and any identifier starting with *->* are all identifiers.
任何以 *->* 开始的都是标识符。
*Identifiers* *are delimited* by whitespace, comments, parentheses, brackets, strin
g(double)quotes("), and hash marks(#).
*标识符* 由 *空白符、注释、圆括号、括号、双引号字符串、哈希标记* 分割。
A delimited or any other Unicode character may be-included any where within the
name of an identifier as an escape of the form _\xsv_, where _sv_ is the scalar
value of the character in hexadecimal natation.
标识符内任何地方可以使用逃逸字符\xsv表示，sv是十六进制数值。
There is no inherent limit on the length of a Scheme identifier;
标识符长度不限；
programmers may use as many characters as necessary.
程序员可以使用必要多的字符。
Long identifiers are no substitute for comments,
长的标识符不能替代注释，
however, and frequent use of long identifiers can make a program difficult to
format and consequently(因此) difficult to read.
然而，频繁使用长标识符会使程序难格式化也因此难以阅读。
*不建议使用长标识符* 
A good rule to use a short identifiers when the scope of identifer is small and
longer identifiers when the scope is larger.
一个好的规则是，小作用域使用短标识符，大作用域使用长标识符。
Identifiers may *be written* in any mix of upper- and lower-case letters, and 
*case is significant(重要/有意义的)*,i.e, For example, abcde, Abcde,AbCDe all 
refer to different identifiers. This is a change from previous versions of the 
Revised Report.
标识符是 *大小写敏感* 的，这是一个不同于以前修订报告。
*** *列表、向量*
Structured forms and list constants *are enclosed within parenthese*, e.g., (a 
b c) or (* (- x 2) y). The empty list *is written ()*.
结构化形式和列表常量使用圆括号包含起来.
Matched sets of brackets([]) may *be used* in place of parentheses and are ofte
n used to set off the subexpressions of certain standards syntactic forms for r
eadability, as shown in examples througout this book.
配对的方括号用于在子表达式中替代圆括号，提高句法的可读性。
Vectors *are written* similary to list, except that they *are preceded* by #(and
 terminated by), e.g., #(this is a vector of symbols).
*向量* 类似列表，但头部(尾部)增加 # 。
Bytevectors *are written* as sequences of unsigned byte values(exact integers 
in  the range 0 through 255) bracketed by *#vu8(...)*, e.g., *#vu8(30 255 46 
78)*.
*字节向量* 以 #vu8 打头 包含 0~255 的数值。

*** Strings(字符串)  and Numbers(数值)
Strings *are enclosed* in double quotation marks, e.g.,"I am a string".
*字符串* 使用双引号包含。
*Characters are preceded by #\, e.g, #\a.*
*字符* 使用 *#\* 前缀，如 #\a 表示字符 a。
Case is important within character and stirng constants, as within identifiers.
和标识符一样，字符串常量和字符常量是 *大小写敏感* 的。
*Numbers* may *be written as integers*, e.g, -123, *as ratios*,e.g, 1/2, in *fl
oating-point* or *scientific notation*,e.g.,1.3 or 1e23, or as *complex number
s in rectangular or polar notations*,e.g.,1.3-2.7i or -1.2@73.
*数值* 表示方式如 *整数* *有理数* *浮点数* *科学表示法* *复数(矩形坐标、极坐标
)* 
Case is not important in the syntax of a number.
*数值表示不区分大小写(大小写不敏感)*
The *boolean* values representing _true_ and _false_ *are written* #t and #f.
*bool 值表示 _真_ _假_ 写成 #t 和 #f*
Scheme conditional expressions actually treat #f as false and all other object
as true, so 3, 0, (), "false" and nil all *count as当作* true.
*Scheme 条件表达式非 #f 即为真*
Details of the syntax for each type of constant data *are given* in the individ
ual sections of Character 6 and the formal syntax of Scheme starting on page 45
5.
常数据语法在第六章，形式语法在455页后又详细介绍。
*** Scheme expressions(表达式) and Comments(注释)
*Scheme expressions* may span several lines, and no explicit terminator is requ
ired.
*Scheme 表达式* 可以跨越多行，并且没有明确的结束限定。
Since the number of whitespace characters(space and newlines) between expressio
ns is not sinificat(总要), Scheme programs *should be intended* to show the str
ucture of the code in a way that makes the code as readable as possible.
由于表达式间有多少空白符并不重要，程序使用 *缩进* 显示代码结构是代码尽可能易读
*Comments* may appear on any line of a Scheme program, between a semicolon(;) a
nd the end of the line.
*注释* 可以出现在任意行使用分号(;)包含.
Comments explaining a particular Scheme expresssion are normally palacd at the 
same indentation level as expresion, on the line before the expression.
注释一个表达式，通常在表达式上一行并和表达式保持同一缩进级别，
Comments explaining a procedure or group of prececdures are normally placed bef
ore the precedures, without identation.
注释一个过程，通常在过程的上面并没有缩进格式。
Multiple comment characters are often used to set offf the latter kind of comme
nt, e.g., ;;; The following precedures ...
使用多个注释符(;;;)来注释多个过程
Two other forms of comments *are supported*: block comments and datum comments.
支持另外两种形式的注视： *块注释* 和 *资料(数据)注释*
*Block comments are delimited by #| and |# pairs, and may be nested.*
块注释使用 *#| ... |#* 分割，并且可嵌套。
A *datum comment* consists of a *#;* prefix and the datum(printed data value) t
hat follows it. Datum comments are typically used to comment out individual def
initions or expressions. For example, *(three #;(not four) element list)* is ju
st what is says.
*资料(数据)注释* 有 *#;* 作为前缀跟随 *数据值* 用于注视单个定义或表达式。
Datum comments may also *be nested*, though #;#;(a)(b) has the somewhat nonobvi
ous effect of commenting out both (a) and (b).
*数据注释* 可以被嵌套
Some Scheme values, such as procedure and ports, do not have standard printed r
epresentations and can thus never appear as constant in the printed syntax of a
 program. The book uses the notation #<description> when showing the output of 
an operation that returns such a value, e.g., #<procedure> or #<port>.
一些 *Sehcme值(如过程、端口)* 不能通过标准打印表现，不能以常理形式打印程序语法，
本书采用 *#<描述>* 的方式显示即 *#<precedure> #<port>*
** 2.Scheme Naming Conventions(Scheme 命名约定)
   Scheme's naming conventions *are designed* to provide a high dagree of regul
arity. The following is a list of these nameing conventions.
*Scheme的命名约定* 被设计成提供高度规则性。 以下列出了命名约定。
- Predicate names end in a question mark(?). Predicates are procedures that ret
  urn a true or false answer, such as eq?,zero?,string?. The common numeric com
  parators =,<,>,<=,>= *are excetions* to this name conversion.
  *谓词* 使用问号(?)结尾。 *谓词是一个返回真假值得过程*
- *Type predicates* such as pair?, *are created* from the name of type, in this
  case pair, and the questiong mark.
  *类型谓词* 使用类型名后缀?表示，如： 是否为pair类型， *pair?*
- The names of procedures that convert an object of one type into an object of 
  another type are-written as type->type2,e.g., *vector->list*.
  过程转化一个对象到另一个对象使用 类型1->类型2。
- The names of precedures and syntactic forms that *cause side effacts* end wit
  h an exclamation point(!).
  对产生副作用的过程和语法形式使用感叹号(!)结尾。
Programmers should employ these same conventions in their own code whenever pos
sible.
程序员任何时候必须在他们的代码中准守以上约定。
** 3.Typographical and Notational Conventions(字体排版与符号预订)
A standard procedure or syntactic form whose sole purpose is to perform some si
de effect is-said to return unspecified.
一个标准过程或句法形式唯一目的是产生返回未知名的一些副作用。(获取结果)
This means that an implementation is free to return any number of values, each 
of which can be any Scheme object, as the value of the procedure or syntactic f
orm.
这意味着一个过程或句法的实现可以返回任意多个值，每个值可以是任意的Scheme对象。
Do not count on these values being the same across implementations, the same ac
ross versions of the same implementation, or even the same across two uses of t
he procedure or syntaticform.
_不要期望这些值在实现上是一样的，相同版本甚至相同的过程或句法。_
Some Scheme systems routinely(常规地) use a special object to represent unspeci
fied values.
通常一些Scheme系统使用特定对象表示未指定的值。
Printing of this object is often suppressed by interactive Scheme systems, so t
hat the values of expressions retuning unspecified values are not printed.
一些交互式Scheme系统抑制打印这些对象，因此表达式返回未知的值不被打印。
While most standard procedures return a single value, the language supports pro
cedure that returns zero, one, more then one, or even a variable number of valu
es via the mechanisms described in Section 5.8.
多数过程放回一个值，语言支持返回0，1，>1 甚至一个可变数量的值(5.8节)。
Some standard expressoins can evaluate to multiple values if one of their subex
pressions evaluates to multiple values,e.g., by calling a procedure that return
s multiple values.
标准表达式可以对多值进程求值，如果他们的子表达式通过调用一个返回多值的过程计算出
多值。
When this situation can occur, an expression is said to return "the values" rath
er than simply "the value" of its subexpression.
但返回多值的情况发生，说放回多个值比返回一个值更合理。
Similary, a standard procedure that returns the values resulting from a call to
 a procedure arguments is said to return the values returnd by the precedure ar
gument.
类似地，一个标准过程从调用一个过程参数返回的值表达成过程参数返回的值。
This book uses the words "must" and "should" to describe program requirements, 
such as the requirement to provide an index that is less then the length of the
 vector in al call to vector-ref. If the word "must" is used, it means that the
 requirement is enforced by the implementation, i.e., an exceptions is raised, 
usually with condition type &assertion. If the word "should" is used, an except
ion may or may not be raised, and if not, the behavior of the program is undefi
ned.
本书使用"必须"和"应该"去表述程序需求，违反使用"必须"的条件见返回异常。违反使用
"应该"的情况可能会产生异常也可能不产生异常但程序结果是未定义的(不可预测的)。

The phrase *syntax violation* *is used* to describe a situation in which a prog
ram *is malformed*. Syntax violation *are deteched prior to* program execution.
When a syntax violation is-deteced, an exception of type &syntax is-raised and 
program is not executed.
*语法错误* 被用来表示程序格式错误的情况。语法错误在程序执行前被检查。但语法错误
被检测到，将产生&syntax类型的异常，程序不被执行。

The typographical conventions used in this book are-straightforward. All Scheme
objects are-printed in a *typewriter typeface打字机字体*, just as they are to b
e typed at the keyboard. This include syntactic keywords, variables, constant o
bjects, Scheme expressions, and example programs. An italic typeface is-used to
set off syntax variables in the descriptions of syntactic forms and arguments i
n the descriptions of procedures. Italics are also used to set off technical te
rms the first time they appear.
本书的印刷约定是简洁的。所有Scheme对象都使用打字机字体，就如同他们从键盘输入的一
样。Scheme 对象包括 *关键字、变量、常量对象、表达式和示例程序* 。 *斜体字* 用于
指出 *句法变量 和 过程参数*, 也用于 *第一次出现的技术术语*。

In general, names of syntactic forms and procedures are never *capitalized大写*
even at the beginning of a sentence. The same is true for syntax varialble writ
ten in italics.
通常句法和过程的名字不会大写，即使是在句首。同样适用于语法变量使用斜体字的形式。

In the description of a syntactic form or procedure, one or more prototype patt
erns show the syntactic form or forms or the correct number of numbers of argum
ents for an application of the procedure.
在描述一个句法形式或一个过程，一个或多个原型样式显示句法形式、形式或应用过程的正
确参数。
The keyword or procedure name is-given in typewrite font, as are-parentheses.
*关键字、过程名、圆括号使用打印机字体*
The remaining pieces of the syntax or arguments are show in italics, using a na
me that implies the type of expression or argument expected by the syntactic fo
rm or procedure.
*其余部分 使用斜体字* 使用名字指出 *表达式类型* 或 *句法、过程的参数*
*Ellipses* are-used to specify *zero or more occurrences* of a subexpression or
arguments. For example, (=or= /expr/ ...) describes the or syntatic form, which 
has zero or more subexpressions, and (=member= /obj/ /list/)describes the member 
procedure, which expects two arugments, an object and a list.
*省略号* 用于指定保护 *0个或多个(不定参数)* 的子表达式或参数。例如(or expr ...)
=or= 句法形式含有0个或多个子表达式。(=member= /obj/ /list/)表示 =member= 过程包
含2个参数，其中一个对象参数和一个列表参数。
A *syntax violation* occors if the structure of a syntactic form not match its 
*prototype*.
如果句法形式不匹配 *句法原型声明* 将发生 *语法错误*。
Similarly, an exception with condition type =&assertion= is-raised if the numbe
r of arguments passed to a standard procedure does not match what it is specifi
ed to receive.
同样，如果一个标准过程的参数传递不匹配他的指定接受类型将抛出 =&assertion= 类型
异常。
A exception with condition type =&assertion= is also raised if a standard proce
dure receives an augument whose type is not the type implied by its name or doe
s not meet other *criteria标准* given in the description of the procedure. For 
example, the prototype for =vector-set!= is =(vector-set /vector/ /n/ /obj/)=
and the description says that =/n/= must be an *exact精确的* nonnegative intege
r *strictly严格的* less than the length of =/vector/=. Thus, =vector-set!= must
recevie three arguments, the first of which must be a vector, the second of whi
ch must be a exact nonnegative integer less than the length of the vector, and 
the third of which may be any Scheme value. Otherwise, an exception with condit
ion type =&assertion= is-raised.
如果一个标准过程接受到不是参数名称指定的类型或符合表述的其他标准，也将抛出异常。
例如句法原型 =(vector-set! /vector/ /n/ /obj/)= 表述了 =/n/= 是精确的非负整数严
格的小于 =vector= 长度，第三个参数是任意的Scheme对象，否则引起断言异常。
In most cases, the type of argument required is *obvious明显的*, as with vector
, =/obj/=, or =/binary-input-port/=.
大部分情况下，参数类型是明显的，如 =/vector,obj,binrary-input-port/= 。
In others, primarily within the descriptions of numeric routines, abbreviations
areused, such as =/int/= for integer, =/exint/= for exact integer, and =/fx/= f
or fixnum. These abbreviations are-explained at the start of the section contai
ning the effected entries.
另外，主要的数值类型使用 *缩写* 形式表示。 *int* 指整数， *exint* 指精确的整数
*fx* 指固定大小的数。 这些缩写在本节开头已经有解释。
* 2. Getting Started(开始)
  This chapter is an introduction to Scheme for programmers who are new to he l
anguage. You will get more from this chapter if you are sitting in front of an 
interactive Scheme system, trying out the examples as you go.
本章正对Scheme新手进行介绍，如果你使用交互式Scheme系统进行训练效果将会效果更好。
After reading this chapter and working the exercise, you should be able to star
t using Scheme. You will have learned the syntax of Scheme program and how they
are-executed, along with how to use simple data structures and control mechanis
ms.
通过阅读本章和完成练习，将掌握如何使用Scheme。将学到Scheme程序语法，其如何被执
行，使用数据结构和控制机制。
** 1.Interacting with Scheme(和Scheme进行交互)
*** 1.交互式环境
   Most Scheme system provide an interactive programming enviroment that simpli
fies program development and experimentation.
大多数Scheme系统提供交互编程环境，这样简化了程序的开发和实验。

The simplest interaction with Scheme follows a "read-evaluate-print" cycle. A p
rogram(often called a read-evaluate-print loop, or REPL) reads each expression 
you type at the keyboard, evaluates it, and prints its value.
最简单的Scheme交互遵循 读-求值-打印 循环。 一个REPL程序读取键盘输入的表达式，对
其进行求值然后把值打印出来。

With an interactive Scheme system, you can type an expression at the keyboard a
nd see its value immediately.
通过Scheme交互系统，可以键盘输入表达式并立刻看到表达式的值。

You can define a procedure and apply it to arguments to see how it works.
可以定义一个过程，用相应的参数调用他，观察其如何工作的。

You can even type in an entire program consisting of a set of procedure definit
ions and test it without leaving the system.
在不断开交互系统前提下，可以编写并测试一个由一系列相关联的过程组成的程序。

When you program starts getting longer, it will be more convenient to type it i
nto a file(using a text editor), load the file and test it interactively.
当程序变得越来越大时，将程序写到文件里面去，并加载文件进行交互式
的测试是一个非常便利的做法。

In most Scheme system, a file may be-loaded with the nonstandard procedure load
, which takes a string argument naming the file.
大多数Scheme系统，使用一个非标准过程 =(load "/file/")= 来加载文件。

Preparing you program in a file has several advantages: you have a chance to co
mpose you program more carefully, you can correct errors without retyping the p
rogram, and you can retain a copy for later use. Most Scheme implementations tr
eat expressions loaded from a file the same as expressoins typed at the keyboar
d.
使用文件来保持程序是非常有利的：
*有机会精心组织程序*
*修改错误是不需要重新打印程序*
*保留一份副本供以后使用*
大多数Scheme实现一致的方式对待 *从文件导入* 和 *键盘输入* 的表达式。

While Scheme provides various input and output procedures, the REPL takes care 
of reading expressions and printing their values. This frees you to concentrate
on writing your program without worrying about how its results will be display
ed.
Scheme 提供多样的输入输出过程， REPL 细心的读取表达式并打印其值。这解放了结果如
何显示的细节思考，专注于编写程序。
*** 2.(表达式)=>表达式输出值
    The examples in this chapter and in the rest of the book follow a regular f
ormat. An expression you might type from your keyboard is-given first, possibly
spanning several lines. The value of expression is-given after the *=>*, to be- 
read as "evaluates to." The => is-omitted for definitions and when the value of
an expression is-unspecified.
本书的示例代码遵循正规格式。一个表达式，可能跨越多行。其值打印在 *=>* 后面，读
作"求值得到"。当未为定义时将 *省略 is-omitted* =>。
*** 3.美观的代码格式
The example programs are-formatted in a style that "looks nice" and conveys the
struct of the program.
示例以"美观"的格式展示程序结构。
The code is easy to read because the relationship between each expression and i
ts subexpressions is clearly shown.
由于表达式和子表达式间清晰地显示结构使得代码阅读非常容易。
Scheme ignores indentation and line breaks, however, so there is no need to fol
low a particular sytle.
Scheme 忽略缩进和换行，然后，他不需要遵守特定的格式。
The important thing is to establish one style and keep to it. Scheme sees each 
programs as if it were on a single line, with its subexpressions ordered from l
eft to right.
只保持一条重要的规则，Scheme对待每个程序为单行代码，以从左到右的顺序排列子表达
式。
*** 4.常量表达式示例
    If you have access to an interactive Scheme system, it might be a good idea
to start it up now and type in the examples as you read.
如果你打开了Scheme交互系统，一个好的主意是现在开始输入每一个你读到的示例代码。
One of the simplest Scheme expressions is a *string constant*.
最简单的表达式是 *字符常量string-constant*.
Try typing "Hi Mom!"(including the double quotes) in response to the prompt.
试着在 *提示符prompt* 后输入"Hi Mom"(包含双引号)。
The system should respond with "Hi Mom!"; the value of any constant is constant
itself.  "Hi Mon" => "Hi Mon"
系统将应答"Hi Mom!"; *常量的值是常量自身*

"hello" => "hello"
42 => 42
22/7 => 22/7
3.141592653 => 3.141592653
+ => #<procedure +>
(+ 76 31) => 107
(* -12 10) => -120
'(a b c d) => (a b c d)

Be careful not to miss any single quotes('), double quotes("), or pharentheses.
*注意不要遗漏任何单引号('),双引号("),圆括号*
If you left off a single quote in the last expression, you probaly received a m
essage indicating that an exception has occurred.
如果你丢了最后那个表达式的单引号，将收到一个异常消息。
Just try again. If you left off a closing parentheses or double quote, the syst
em might still be waiting for it.
在尝试一次，如果你遗漏由圆括号或双引号，系统将继续等待输入。

There are a few more expressions to try. You can try to figure out on your own 
what they mean or wait to find out later in the chapter.
这里是更多表达式，可以指出其含义或者在本章的后续找出其含义。
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cons 'a '(b c)) => (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)

As you can see, Scheme expressions may span more then one line. The Scheme know
s when it has a entire expression by matching double quotes and parentheses.
如上Scheme表达式可以跨越多行。Scheme通过配对双引号和圆括号来识别出完整的表达式。
*** 5.定义过程(defining a procedure)
    Next, let's try defining a procedure.
    接下来，让我们尝试定义一个过程。
#+BEGIN_SRC scheme
;; square(n)
(define square
  (lambda (n)
    (* n n)))
#+END_SRC
The procedure =square= computes the square n^2 of any number n. We say more abo
ut the expressions that make up this deifnitions later in this chapter.
这个过程计算了n的平方。我们将在本章的后面更多地讲解这个表达式组成。
For now it suffices to say that =define= establishes variable bindings =lambda=
creates procedures, and =*= names the multiplicatoin procedure.
当前将 =define= 理解为建立变量绑定， =lambda= 理解为创建过程， =*= 表示乘法过程
就 *足够suffices* 了。
Note the form of these expressions.
记住这些表达式的形式。
All structured forms *are-enclosed in parentheses* and written in *prefix notation*
i.e., the operator precedes the arugments.
所有形式的构造都 *被一对圆括号包围* ，并且采用 *前序标记法* 即操作在参数前面。
As you can see, this is true even for simple arithmetic orprations such as *.
如你所见，乘法操作数也是如此，采用前序标记法。
Try using square.

(square 5) => 25
(square -200) => 40000
(square 0.5) => 0.25
(square -1/2) => 1/4

Even through the next definition is short, you might enter it into a file. Let'
s assume you call the file "reciprocal.ss".
让我们定义一个叫倒数的过程，保存到 "reciprocal.ss" 文件中，虽然有代码点短。
#+BEGIN_SRC scheme
(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))
#+END_SRC
This procedure, =reciprocal=, computes the quantity 1/n for any number n!=0. Fo
r n = 0, =reciprocal= returns the string "oops!". Return to Scheme and try load
ing your file with procedure =load=.
=reciprocal= 这个过程当n不等于0时对n求倒数，当n等于0时返回"oops!"字符串。保存文
件后，使用 =load= 加载这个过程。
Finally, try using the procedure we have just defined.

(reciprocal 10) => 1/10
(reciprocal 1/10) => 10
(reciprocal 0) => "oops!"
(reciprocal (reciprocal 1/10)) => 1/10

In the next section we will discuss Scheme expressions in more detail.
在下一节我们将更详细的讨论表达式。
Throughout this chapter, keep in mand that your Scheme system is one of the mos
t useful tools for learning Scheme.
请记住Scheme交互系统是最有效的学习Scheme编程的方式。
Whenever you try one of the examples in the text, follow it up with your own ex
amples. In an interactive Scheme system, the cost of trying something out is re
latively small--usually just the time to type it in.
每当尝试一个示例，非常的便捷，仅仅需要打印一下的时间 。
** 2.Simple Expressions(简单的表达式)
   The simplest Scheme expression are *constant data objects*, such as strings,
numbers, symbols, and list.
最简单的Scheme表达式是 *数据对象常量* 例如：字符串，数值，符号，列表。
Scheme supports other object types, but thess for are enough for many programs.
Scheme 支持其他的对象类型，但上面的四类对象已经满足很多程序的需求。
We saw some examples of strings and numbers in preceding section.
我们在前面一节已经看到了一些字符串和数值的示例。
*** 1.讨论数值细节(discuss numbers in a little more detail)
    Let's discuss numbers in a little more detail. Number are *constants*. If y
ou enter a number, Scheme echos it back to you. The following examples show tha
t Scheme supports several types of numbers.
123456789987654321 => 123456789987654321
3/4 => 3/4
2.718281828 => 2.718281828
2.2+1.1i => 2.2+1.1i
让我们在详细一点的讨论数值。数值是一个常数。如果输入一个数值，Scheme将回射这个数
。下面的示例显示了Scheme支持多种数据类型。

Scheme numbers include *exact integer* and *inexact integer*, *rational*, *real*
*complex numbers*.
Scheme数值包含 *精确整数* *不精确整数* *有理数* *实数* *复数*
Exact integers and retional numbers have arbitrary precision, i.e., they can be 
arbitrary size.
精确整数和有理数具有 *任意的精度*, 即其大小是任意的。
Inexatc numbers are usually represented internally using IEEE standard floating
-point representations.
非精确数值通常使用IEEE标准的浮点数表示。
*** 2.数学运算符过程(arithmetic procedures)
    Scheme provides the names *+ - * /* for corresponding arithmetic procedures
Each procedure accepts two numeric arguments.
Scheme 提供 *+ - * /* 为相应的数学运算过程。每个运算符接受2个参数。

The expressions below are-called *precedure applications*, because the specify 
the application of a procedure to a set of arugments.
(+ 1/2 1/2) <graphic> 1
(- 1.5 1/2) <graphic> 1.0 

(* 3 1/2) <graphic> 3/2
(/ 1.5 3/4) <graphic> 2.0
一下表达式被称为 *过程应用程序* ，因为应用程序指定了一个参数集合到了一个过程。
Scheme employs prefix notation even for common arithmetic operations.
*** 3.前序标记法
Scheme 对数学运算符同样采用 *前序标记法* 。
Any procedure application, whether the procedure taske zero, one or two, or mor
e arugments, is-written as =(procedure /arg/ ...)=.
任何过程应用程序，不论其包含 0，1，2，... 个参数都写成 =(procedure /arg/ ...)=
This regularity simplifies the syntax of expressions;
*前序标记法* 规则简化了表达式的语法；
one notation is-employed regardless of the operation, and there are no complica
ted rules regarding the precedence or assiciativity of operators.
*前序标记法* 是的任意的操作只遵循一个标准，没有复杂的运算符优先级和结合性问题。
*** 4.过程嵌套(Procedure applications may be-nested)
    Procedure applications may be-nested, in which chase the innermost values a
re computed first. We can thus nest applications of the arithmetic procedure gi
ven above to evalute more complicated formulas.
(+ (+ 2 2) (+ 2 2)) => 8
(- 2 (* 4 1/3)) => 2/3
(* 2 (* 2 (* 2 (* 2 2)))) => 32
(/ (* 6/7 7/2) (- 4.5 1.5)) => 1.0

过程可以被嵌套，当需要 *内部值innermost* 先被计算时。我们可以嵌套算数过程来计算
更 *复杂的公式complicated formulas* 。

These examples demonstrate everything you need to use Scheme as a four-function
desk calculator.
上面这些示例演示了使用Scheme实现一个 *四则运算* 的桌面计算器。
While we will not discuss them in this chapter, Scheme supports many other arit
hmatic preocdures.
本章我们不讨论Scheme支持的其他算数运算过程。
Now might be a good time to turn to Section 6.4 and experiment with some of them.
现在可能是一个好时机，跳到6.4节去实验他们。

*** 5.聚合数据结构(aggregate data structures)
    Simple numeric objects are sufficient for many tasks, but sometimes aggrega
te data structures containing two or more values are-needed.
简单数值通常是满足一些任务的需求，但有时需要包含两个及以上值得 *数据结构* 。
*** 6.列表(数据聚合的基础)
In many languages, the basic aggregate data structure is the array. In Scheme, 
it is the *list*.
在多少语言中数组是聚合数据结构的基础，但在Scheme中 *list* 是聚合数据的基础。
List are-written as sequences of objects surrounded by parentheses. For instanc
e, (1 2 3 4 5) is a list of numbers, and ("this" "is" "a" "list") is a list of 
string.
*列表* 在书写时被一对圆括号包含，如(1 2 3 4 5)是数值列表，("this" "is" "a" "list")
是一个字符串列表。
List need not contain only one type of object, so (4.2 "hi") is a valid list co
ntaining a number and a string.
*列表* 不局限于包含一类对象。
Lists may be nested (may contain other list), so ((1 2) (3 4))is a valid list w
ith two elements, each of which is a list of two elements.
*列表* 可以 *嵌套*
*** 7.单引号运算符(' 明确指定为列表)
    You might notice that list looks just like procedure applications and wonde
r how Scheme tell them apart. That is, how does Scheme distinguish between a li
st of objects =(/obj1/ /obj2/ ...)= and a procedure application 
=(proc /arg/ ...)=
你也许发现了列表和过程非常相似，并向知道Scheme如何区分列表和过程。
In some cases, the distinction might seem obvious. The list of numbers (1 2 3)
could hardly be-confused with a procedure application, since 1 is a number, no
t a procedure.
一些情况下，区别是明显的。列表(1 2 3)很难和过程混淆，因为1是数值不是过程。
So, the answer might be that Scheme looks at the first element of the list or
procedure application and makes its decision based on whether that firt element
is a procedure or not.
因此，一个可能的答案是看第一项是否为过程。
This answer is not good enough, since we might even want to treat a valid proce
dure application such as (+ 3 4) as a list.
这个答案并不足够好，因为有时我们想将一个过程视作一个列表，如(+ 3 4)。
The answer is that we must tell Scheme explicitly to treat a list as data rathe
r than as a procedure application. *We do this with quote*

(quote (1 2 3 4 5)) => (1 2 3 4 5)
(quote ("this" "is" "a" "list")) => ("this" "is" "a" "list")
(quote (+ 3 4)) => (+ 3 4)

正确答案是我们通过 *前缀单引号的方式来明确告示Scheme将过程视作列表* 。

The =quote= forces the list to be-treated as data. Try entering the above expre
ssions without the quote; you will likely receive a message indicating that an 
excetpions has occurrd for the first two and an incorrent answer(7) for the thi
rd.
=quote= 强制列表视作数据。试着不带quote输入以上表达式，你将收到一个消息指出前两
个表达式一次和第三个表达式返回一个不完整的答案7。

Because =quote= is-required firly frequently in Scheme code, Scheme recognizes 
a single quotion mark (') precedding an expression as an abbreviation for quote
#+BEGIN_SRC scheme
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
#+END_SRC
应为 =quote= 使用非常频繁，为了方便Scheme使用缩写的单引号 ' 前缀到表达式上。
Both forms are-refered to as quote expressions. We often say an object is-quote
d when it is enclose in a quote expression.
=(quote (1 2 3))= 和 '(1 2 3) 是等价的表达式。当单引号包含一个表达式时通常称对象
被引用。
A quote expression is /not/ a procedure application, since is *inhibits(阻止)* 
the evaluation of its subexpression. It is a entirely different syntactic form.
引用表达式不是过程，应为阻止了其子表达式被求值。这是一个完全不同的句法。
Scheme supports several other syntactic forms in addition to preocedure applica
tions and quote expressions.
除quote句法外，Scheme 还支持另外几种句法。
Eache syntactic form is-evaluated differently. Fortunately, the number of diffr
rent syntactic is small. We will see more of them in this chapter.
每种句法都有不同的求值方式。幸运的是句法不多，我们将在本周看到大部分。
*** 8.符号与变量(symbol and variable)
Not all quote expressions involve lists. Try the following expression with and 
without the quote wrapper.
(quote hello) => hello
不是所有引用表达式都包含列表。
The *symbol* hello must be-quoted in orde to *prevent防止* Scheme from treating
hello as a /variable/.
符号hello必须被引用，为了防止hello被当作变量。
Symbols and variables in Scheme are similar to symbols and viarables in mathema
tical expressions and equations.
Scheme的符号和变量类似于数学表达式和方程式的符号和变量。
When we evaluate the mathmatical expression 1 - x for some value of x, we think
of x as a *variable*.
当我们使用x的一些值求值一个数学表达式(1 - x)时，我们把x想象成变量。
On the other hand, wend we consider the *algebraic equation* x^2 - 1 = (x-1)(x+
1), we think of x as a *symbol* (in fact, we tink of the whole equation symboli
cally).
另一方面，我们认为代数方程式是一个符号。
Just as quoting a list tells Scheme to treat a parenthesized form as a list rah
her than as a procedure applicatoin, quoting an identifire tell Scheme to treat
the identifier as a symbol than as a variable.
就如同引用一个列表告知Scheme将括号内的形式视作列表而不是过程，引用一个标识符告
诉Scheme将标识符作为符号而不是变量。
While symbols are commonly used to represent variables in symbolic representati
ions of equations or program, symbols may also be-used, for example, as words i
n the representation of natural language sentence.
在方程式或程序中，符号通常被表示为变量，如在自然语言中符号表示成单词。
*** 9.程序也是数据(同质特性)
You might wonder why applicatons and variables shared notations with list and s
ymbols.
你可能想知道为什么程序和变量都使用同一种标记法，列表和符号。
The shared notation allows Scheme programs to be-represented as Scheme data, si
plifying the writing of interpreters, compilers, editors, and other tools in Sc
heme.
*共享标记法使得Scheme程序可视作Scheme数据，这样简化了解释器，编译器，编辑器和*
*其他Scheme工具的开发*
This is-demonstrated by the Scheme interpreter given in Scetion 12.7, which is 
itself written in Scheme. Many people believe this is to be one of the most im
portant features of Scheme.
使用Scheme语言编写Scheme语言的解释器，很多人相信这是Scheme语言的重要特性。
*** 10.数据、字符串的引用就是自身
    Numbers and strings may be quoted, too.
'1 => 1
'2/3 => 2/3
(quote "Hi Mom!") => "Hi Mom!"
Number and string are-treated as constants in any case, however, so quoting the
m is unnecessary.
在任何情况下数值和字符串被当作常来，因此不需要进行引用操作。
*** 11.列表操作过程(procedures for manipulating lists)
    Now let's discuss some Scheme proecedure for manipulating lists. There are 
two basic procedure for taking lists apart: =car= and =cdr= (pronouced could-er
). =car= return the first element of a list, and =cdr= returns the remainder of
the list.(The names car and cdr are-derived from operations supported by the fi
rst computer on which a Lisp language was-implemented, the IPM 704.)Each requir
es a nonempty list as its arguments.
现在让我们讨论一些列表操作相关的过程。有两个基本过程，car 获取列表的第一项，cdr
获取列表的后续项。car和cdr都需要一个非空列表作为其参数
(car '(a b c)) => a
(cdr '(a b c)) => (b c)
(cdr '(a)) => () 

(car (cdr '(a b c))) => b
(cdr (cdr '(a b c))) => (c) 

(car '((a b) (c d))) => (a b)
(cdr '((a b) (c d))) => ((c d))

(cons 'a '()) => (a)
(cons 'a '(b c)) => (a b c)
(cons 'a (cons 'b (cons 'c '()))) => (a b c)
(cons '(a b) '(c d)) => ((a b) c d) 

(car (cons 'a '(b c))) => a
(cdr (cons 'a '(b c))) => (b c)
(cons (car '(a b c))
      (cdr '(d e f))) => (a e f)
(cons (car '(a b c))
      (cdr '(a b c))) => (a b c)

*proper list(常规列表)*
(a b)
[a,-]->[b,()]
*improper/dotted list(非常规/点列表)*
(a . b)
[a,b]

** 3. Evaluating Scheme Expressions(表达式求值)
   Let's turn to a discussion of how Scheme evaluates the expressions you type.
下面我们讨论Scheme是如何求值表达式。 
We have already established the rules for constant objects such as strings and 
numbers: the object itself is the value.
我们已经建立了对象构造规则，如字符串和数值对象本身就是表达式值。
You have probably also worked out in your mind a rule for evaluating applicatio
ns of the form =(procedure arg1 ... argn)= .
你可能在自己的脑海中已经算出 =(procedure arg1 ... argn)= 的求值过程。
Here, /porcedure/ is an expression representing a Scheme procedure, and arg1 ..
argn are expressions representing its arugments. One possiblity is the following
*(quote expressons) 引用表达式不求值*
Constant objects, preocedure applications, quote expressions are only three of 
many syntactic forms provided by Scheme.
*常量、过程、引用 三类核心句法， 外还有少数其他句法根据核心句法扩展的*
*扩展句法 (let ((key value) ...)) (lambda (arg...) body...)*
1. 从左向右求值
2. 过程变量求值方式和过程求值一样
(car '(+ - * /) 2 3) => Exception: attempt to apply non-procedure +
(car (+ - * /) 2 3) => Exception in +: #<procedure -> is not a number
*(car (list + - * /) 2 3) => 5*
** 4.Variables and Let Expressions
*(let ((var expr)...) body1 body2 ...)*
*let* 句法实现了 一个 *值* *绑定* 一个 *变量*
优点：避免相同表达式的重复写于计算。
  (+ (* 4 4) (* 4 4)) => 32
  (let ((a (* 4 4))) (+ a a)) => 32
*[] 可以替代 () 方便阅读*
[let [[x 2]] [+ 2 x]] => 4
*变量作用域在let表达式内*
*(let ...) 可嵌套定义*
*如有同名变量，内存变量则掩盖外层变量，使得外表变量不可见*
(let ([x 1])
  (let ([x (+ x 1)])
    (+ x x))) => 4
外部x *scope作用域* 外部括号 减去 内部括号；
*lexical scope词法作用域*
** 5. Lambda Expressions (lambda 表达式)(简单理解为匿名过程)
lambda 解决了 let 表达式的局限；
((lambda (x) (+ x x)) 3) ==> 6
(let ([x 3]) (+ x x))

let/lambda 混合应用

(let ([x 'a])
  (let ([f (lambda (y) (list x y))])
    (f 'b))) => (a b)
x 相对于 lambda 是自由变量， *自由变量必须已绑定* ；
y 相对于 lambda 不是自由变量；

*(let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)*
*let 是由 lambda 扩展的*

(let ([f (lambda x x)])
  (f 1 2 3 4)) => (1 2 3 4) 

(let ([f (lambda x x)])
  (f)) => () 

*lambda (x . y) y 表示所有剩余的参数, 类似C的 fn(args ...)*
(let ([g (lambda (x . y) (list x y))])
  (g 1 2 3 4)) => (1 (2 3 4)) 

(let ([h (lambda (x y . z) (list x y z))])
  (h 'a 'b 'c 'd)) => (a b (c d))

> (let ([f (lambda (x) x)])
  (f 'a))
a
> (let ([f (lambda x x)])
  (f 'a))
(a)
> (let ([f (lambda (x . y) x)])
  (f 'a))
a
> (let ([f (lambda (x . y) y)])
  (f 'a))
()
> 
How might the primitive procedure list be-defined?
** 6. Top-Level Definitions(顶层定义/全局定义)
   let, lambda 表达式绑定的变量对外不可见。
   顶层定义(全局可见，除了被内部定义覆盖外)
   *define* 创建一个顶层定义对象
   #+BEGIN_SRC scheme
   (define double-any
     (lambda (f x)
       (f x x)))
   #+END_SRC
** 2.9 Assignment(分派)
   #+BEGIN_SRC scheme
   ;; 全局变量
   (define abcde '(a b c d e))
   (set! abcde (cdr abcde))
   ;; 局部作用域覆盖全局作用域
   (let ([abcde '(a b c d e)])
     (set! abcde (reverse abcde))
     abcde)
   ;; 变量不需要声明，可直接使用
   ;; 请平方根 (-b(+/-)(b^2 - 4ac))/2a
   (define quadratic-formula
     (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
         (set! minusb (- 0 b))
         (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
         (set! divisor (* 2 a))
         (set! root1 (/ (+ minusb radical) divisor))
         (set! root2 (/ (- minusb radical) divisor))
         (cons root1 root2))))
   ;; without assignment
   (define quadratic-formula
     (lambda (a b c)
       (let ([minusb (- 0 b)]
             [radical (sqrt (- (* b b) (* 4 (* a c))))]
             [divisor (* 2 a)])
         (let ([root1 (/ (+ minusb radical) divisor)]
               [root2 (/ (- minusb radical) divisor)])
           (cons root1 root2)))))
   ;; let 只读；let! 可读写

   ;; 本地状态缓存
   (define lzay
     (lambda (t)
       (let ([val #f] [flag #f])
         (lambda ()
           (if (not flag)
               (begin (set! val (t))
                      (set! flag #t)))
           val))))
   #+END_SRC
* 3. Going Further(进阶)
** 3.1 Syntatic Extension(语法扩展)
   核心句法
   (define ...)
   constans
   varialbes
   procedure application
   quote expressions
   lambda expressions
   if expressions
   set! expressions

<program>	<graphic>	<form>*
<form>	<graphic>	<definition> | <expression>
<definition>	<graphic>	<variable definition> | (begin <definition>*)
<variable definition>	<graphic>	(define <variable> <expression>)
<expression>	<graphic>	<constant>
|	<variable>
|	(quote <datum>)
|	(lambda <formals> <expression> <expression>*)
|	(if <expression> <expression> <expression>)
|	(set! <variable> <expression>)
|	<application>
<constant>	<graphic>	<boolean> | <number> | <character> | <string>
<formals>	<graphic>	<variable>
|	(<variable>*)
|	(<variable> <variable>* . <variable>)
<application>	<graphic>	(<expression> <expression>*)

(begin e1 e2 ...) == ((lambda () e1 e2 ...))

(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]))
   扩展句法

** 3.2 More Recursion(更多递归)
** 3.3 Continuations(连续性)
** 3.4 Continuation Pass Style(连续传输方式)
** 3.5 Internal Definitions(内部定义)
** 3.6 Libraries(库)
* 5. Control Operations
** 5.4.Recursion and Iteration
*** syntax: (do ((var init update) ...) (test result ...) expr ...)
    returns: the values of the last result expression 
    libraries: (rnrs control), (rnrs)
    
    do{body...; update}while(test); expr
    
* 6. Operations on Objects(对象的操作)
  本章描述对象支持的操作，对象包括：
  list,numbers,characters,strings,vectors,bytevectors,symbols,booleans,
  hashtables,enumerations.
** 6.1 Constants and Quotation(常量和引用)
   [[file:../src/tspl-6-Operations-on-Objects/6.1-Constants-and-Quotation.ss]]

*** 常量
    syntax: constant 
    returns: constant
    
*** 引用
    syntax: (quote obj) 
    syntax: 'obj 
    returns: obj 
    libraries: (rnrs base), (rnrs)

    引用阻止了对象的求值，使对象作为数据。
    常量的引用时自身，所以常量不需要进行引用。
    引用、常量时不变的，不能通过set-car!,string-set!来操作，否则抛出异常
    
**** syntax: (quasiquote obj ...) 
     准引用
     syntax: `obj
     
     反引用，准引用中的内容进行求值，后拼接
     syntax: (unquote obj ...)
     syntax: ,obj 
     
     作用将列表/向量内容提取出来，拼接
     syntax: (unquote-splicing obj ...) 
     syntax: ,@obj 

     但它允许引用文本的部分内容“进行求值”
     unquote和unquote-splicing仅在quasiquote表达式中有效。
     
** 6.2.Generic Equivalence and Type Predicates
   [[file:../src/tspl-6-Operations-on-Objects/6.2-Generic-Equivalnce-and-Type-Precidcates.ss]]

   谓词：返回#t或#f的过程
   
*** procedure: (eq? obj1 obj2) 
    returns: #t if obj1 and obj2 are identical, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    eq? obj1,obj2指向的指针相同返回#t,否则#f。
    - 两个不同类型的对象（布尔值，空列表，对，数字，字符，字符串，向量，符号和过程）是不同的。
    - 具有不同内容或值的两个相同类型的对象是不同的。
    - 布尔对象#t无论出现在哪里都与自身相同，并且#f在任何地方都与自身相同，但#t和#f是不同的。
    - 空列表（）在其出现的任何地方都是相同的。
    - 当且仅当它们具有相同的名称时，两个符号是相同的（通过string =？）。
    - 不能用于可靠地比较数字和字符。

*** procedure: (eqv? obj1 obj2) 
    returns: #t if obj1 and obj2 are equivalent, #f otherwise 
    libraries: (rnrs base), (rnrs)

    eqv? obj1,obj2 值相等且除eq?,eqv?外不能区分不等；
    
    
*** procedure: (equal? obj1 obj2) 
    returns: #t if obj1 and obj2 have the same structure and contents, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    
*** procedure: (boolean? obj) 
    returns: #t if obj is either #t or #f, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    (lambda (x) (or (eq? x #t) (eq? x #f)))

*** procedure: (null? obj) 
    returns: #t if obj is the empty list, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
    (lambda (x) (eq? x '()))

*** procedure: (pair? obj) 
    returns: #t if obj is a pair, #f otherwise 
    libraries: (rnrs base), (rnrs)
    
*** procedure: (number? obj)
    returns: #t if obj is a number object, #f otherwise 
    procedure: (complex? obj) 
    returns: #t if obj is a complex number object, #f otherwise 
    procedure: (real? obj) 
    returns: #t if obj is a real number object, #f otherwise 
    procedure: (rational? obj) 
    returns: #t if obj is a rational number object, #f otherwise 
    procedure: (integer? obj) 
    returns: #t if obj is an integer object, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (real-valued? obj) 
    returns: #t if obj is a real number, #f otherwise 
    procedure: (rational-valued? obj) 
    returns: #t if obj is a rational number, #f otherwise 
    procedure: (integer-valued? obj) 
    returns: #t if obj is an integer, #f otherwise 
    libraries: (rnrs base), (rnrs)

    虚部为0.0i时 同real?,rational?,integer?

*** procedure: (char? obj) 
    returns: #t if obj is a character, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (string? obj) 
    returns: #t if obj is a string, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (vector? obj) 
    returns: #t if obj is a vector, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (symbol? obj) 
    returns: #t if obj is a symbol, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (procedure? obj) 
    returns: #t if obj is a procedure, #f otherwise 
    libraries: (rnrs base), (rnrs)

*** procedure: (bytevector? obj) 
    returns: #t if obj is a bytevector, #f otherwise 
    libraries: (rnrs bytevectors), (rnrs)

*** procedure: (hashtable? obj)
    returns: #t if obj is a hashtable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)
** 6.3.List and Pairs
   pair(cons cell) 基本结构对象。
   [ car . cdr ]-->[last-element . ()]
      |     |                       \- 常规列表(),非常规列表可以时任意对象
      |     \- linked one to the next
      \- element
*** 构造形态
**** 构造二叉树
                [ptr.ptr]
                 /    \
               car   cdr
**** 常规链表
    [car . cdr]-->[car . cdr]-->...-->[car.()]
**** 非常规链表
    [car . cdr]

    (1 2 3 . 4)
    [1.*]-->[2.*]-->[3.4]

    ((1.2).3)
       [*.3]
       /
    [1.2]

    (1 . (2 . (3 . ())))
    (1 2 3)
    [1.*]-->[2.*]-->[3.()]
**** 环形链表
    set-car!,set-cdr!来改变car，cdr实现环形链表
    [1.*]-->[2.*]-->[3.*]->+
       \---<---------------+
*** procedure: (cons obj1 obj2) 
    returns: a new pair whose car and cdr are obj1 and obj2 
    libraries: (rnrs base), (rnrs)
*** procedure: (car pair) 
    returns: the car of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (cdr pair) 
    returns: the cdr of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (set-car! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (set-car! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (set-cdr! pair obj) 
    returns: unspecified 
    libraries: (rnrs mutable-pairs)
*** procedure: (caar pair) 
    procedure: (cadr pair)
    procedure: (cddddr pair) 
    returns: the caar, cadr, ..., or cddddr of pair 
    libraries: (rnrs base), (rnrs)
*** procedure: (list obj ...) 
    returns: a list of obj ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (cons* obj ... final-obj) 
    returns: a list of obj ... terminated by final-obj 
    libraries: (rnrs lists), (rnrs)
*** procedure: (list? obj) 
    returns: #t if obj is a proper list, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (length list) 
    returns: the number of elements in list 
    libraries: (rnrs base), (rnrs)
*** procedure: (length list) 
    returns: the number of elements in list 
    libraries: (rnrs base), (rnrs)
*** procedure: (list-ref list n) 
    returns: the nth element (zero-based) of list 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define list-ref
      (lambda (ls n)
        (if (= n 0)
            (car ls)
            (list-ref (cdr ls) (- n 1))))) 
    #+END_SRC
*** procedure: (list-tail list n) 
    returns: the nth tail (zero-based) of list 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define list-tail
      (lambda (ls n)
        (if (= n 0)
            ls
            (list-tail (cdr ls) (- n 1))))) 
    #+END_SRC
*** procedure: (append) 
    procedure: (append list ... obj) 
    returns: the concatenation of the input lists 
    libraries: (rnrs base), (rnrs)
    #+BEGIN_SRC scheme
    (define append
      (lambda args
        (let f ([ls '()] [args args])
          (if (null? args)
              ls
              (let g ([ls ls])
                (if (null? ls)
                    (f (car args) (cdr args))
                    (cons (car ls) (g (cdr ls)))))))))
    #+END_SRC
*** procedure: (reverse list) 
    returns: a new list containing the elements of list in reverse order 
    libraries: (rnrs base), (rnrs)
    
    #+BEGIN_SRC scheme
    (define reverse
      (lambda (ls)
        (let rev ([ls ls] [new '()])
          (if (null? ls)
              new
              (rev (cdr ls) (cons (car ls) new)))))) 
    #+END_SRC
*** procedure: (memq obj list) 
    eq? member
    procedure: (memv obj list) 
    eqv? member
    procedure: (member obj list) 
    equal? member
    returns: the first tail of lwist hose car is equivalent to obj, or #f 
    libraries: (rnrs lists), (rnrs)

    #+BEGIN_SRC scheme
    (define memq
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eq? (car ls) x) ls]
          [else (memq x (cdr ls))])))
    #+END_SRC
*** (memp procedure list) 
    returns: the first tail of list for whose car procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (remq obj list) 
    procedure: (remv obj list) 
    procedure: (remove obj list) 
    returns: a list containing the elements of list with all occurrences of obj removed 
    libraries: (rnrs lists), (rnrs)
*** procedure: (remp procedure list) 
    returns: a list of the elements of list for which procedure returns #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (filter procedure list) 
    returns: a list of the elements of list for which procedure returns true 
    libraries: (rnrs lists), (rnrs)
*** procedure: (partition procedure list) 
    returns: see below 返回多值 = 2list，#t + #f
    libraries: (rnrs lists), (rnrs)
*** procedure: (find procedure list) 
    returns: the first element of list for which procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (assq obj alist) 
    procedure: (assv obj alist) 
    procedure: (assoc obj alist) 
    returns: first element of alwist hose car is equivalent to obj, or #f 
    libraries: (rnrs lists), (rnrs)
    #+BEGIN_SRC scheme
    (define assq
      (lambda (x ls)
        (cond
          [(null? ls) #f]
          [(eq? (caar ls) x) (car ls)]
          [else (assq x (cdr ls))])))
    #+END_SRC
*** procedure: (assp procedure alist) 
    returns: first element of alist for whose car procedure returns true, or #f 
    libraries: (rnrs lists), (rnrs)
*** procedure: (list-sort predicate list) 
    returns: a list containing the elements of list sorted according to predicate 
    libraries: (rnrs sorting), (rnrs)
    

** 6.4.Numbers
   分类为整数，有理数，实数或复数。
   因为所有整数都是理性的，所有有理数都是实数，所有实数都是复数。
   也可以归类为精确或不精确,exact? inexact?
   Scheme中对数字的大多数操作都是精确保留：如果给定精确操作数，它们返回精确值，
   如果给出不精确的操作数或精确和不精确操作数的组合，则返回不精确的值。
   精确整数和有理算术通常支持任意精度;
   
   3+4i, 3.2-3/4i, +i
   1.1@1.764 and -1@-1/2 

   +inf.0 and -inf.0 正/负无穷大
   +nan.0/-nan.0 非数值

   - #e,#i 强制数字精确性
   - 默认10进制，#b(binary),#o(otcal),#d(decimal),#x(hexadecimal)
   - 但是系统打印机（由put-datum，write和display调用）和number-> string以紧凑的形式表示数字，
*** procedure: (exact? num) 
    returns: #t if num is exact, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (inexact? num) 
    returns: #t if num is inexact,e #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (= num1 num2 num3 ...) 
    procedure: (< real1 real2 real3 ...) 
    procedure: (> real1 real2 real3 ...) 
    procedure: (<= real1 real2 real3 ...) 
    procedure: (>= real1 real2 real3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (+ num ...) 
    returns: the sum of the arguments num ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (- num) 
    returns: the additive inverse of num 
    procedure: (- num1 num2 num3 ...) 
    returns: the difference between num1 and the sum of num2 num3 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (* num ...) 
    returns: the product of the arguments num ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (/ num) 
    returns: the multiplicative inverse of num 
    procedure: (/ num1 num2 num3 ...) 
    returns: the result of dividing num1 by the product of num2 num3 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (zero? num) 
    returns: #t if num is zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (positive? real) 
    returns: #t if real is greater than zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (negative? real) 
    returns: #t if real is less than zero, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (even? int) 
    returns: #t if int is even, #f otherwise
*** procedure: (odd? int) 
    returns: #t if int is odd, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (finite? real) 
    returns: #t if real is finite, #f otherwise 
*** procedure: (infinite? real) 
    returns: #t if real is infinite, #f otherwise 
*** procedure: (nan? real) 
    returns: #t if real is a NaN, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (quotient int1 int2) 
    returns: the integer quotient of int1 and int2 
    procedure: (remainder int1 int2) 
    returns: the integer remainder of int1 and int2 
    procedure: (modulo int1 int2) 
    returns: the integer modulus of int1 and int2 
    libraries: (rnrs r5rs)
*** procedure: (div x1 x2) 
    procedure: (mod x1 x2) 
    procedure: (div-and-mod x1 x2) 
    returns: see below 
*** procedure: (div0 x1 x2) 
    procedure: (mod0 x1 x2) 
    procedure: (div0-and-mod0 x1 x2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (truncate real) 
    returns: the integer closest to real toward zero 
    libraries: (rnrs base), (rnrs)
*** procedure: (floor real) 
    returns: the integer closest to real toward -inf.0
    libraries: (rnrs base), (rnrs)
*** procedure: (ceiling real) 
    returns: the integer closest to real toward +inf.0
    libraries: (rnrs base), (rnrs)
*** procedure: (round real) 
    returns: the integer closest to real 
    libraries: (rnrs base), (rnrs)
*** procedure: (abs real) 
    returns: the absolute value of real 
    libraries: (rnrs base), (rnrs)
*** procedure: (max real1 real2 ...) 
    returns: the maximum of real1 real2 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (min real1 real2 ...) 
    returns: the minimum of real1 real2 ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (gcd int ...) 
    returns: the greatest common divisor of its arguments int ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (lcm int ...) 
    returns: the least common multiple of its arguments int ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (expt num1 num2) 
    returns: num1 raised to the num2 power 
    libraries: (rnrs base), (rnrs)
*** procedure: (inexact num) 
    returns: an inexact representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact num) 
    returns: an exact representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact->inexact num) 
    (为兼容Revised5)
    returns: an inexact representation of num 
    procedure: (inexact->exact num) 
    returns: an exact representation of num 
    libraries: (rnrs r5rs)
*** procedure: (rationalize real1 real2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (numerator rat) 
    returns: the numerator of rat 
    libraries: (rnrs base), (rnrs)
*** procedure: (denominator rat) 
    returns: the denominator of rat 
    libraries: (rnrs base), (rnrs)
*** procedure: (real-part num) 
    returns: the real component of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (imag-part num) 
    returns: the imaginary component of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-rectangular real1 real2) 
    returns: a complex number with real component real1 and imaginary component real2 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-polar real1 real2) 
    returns: a complex number with magnitude real1 and angle real2 
    libraries: (rnrs base), (rnrs)
*** procedure: (angle num) 
    returns: the angle part of the polar representation of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (magnitude num) 
    returns: the magnitude of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (sqrt num) 
    returns: the principal square root of num 
    libraries: (rnrs base), (rnrs)
*** procedure: (exact-integer-sqrt n) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (exp num) 
    returns: e to the num power 
    libraries: (rnrs base), (rnrs)
*** procedure: (log num) 
    returns: the natural logarithm of num 
    procedure: (log num1 num2) 
    returns: the base-num2 logarithm of num1 
    libraries: (rnrs base), (rnrs)
*** procedure: (sin num) 
    procedure: (cos num) 
    procedure: (tan num) 
    returns: the sine, cosine, or tangent of num 
    libraries: (rnrs base), (rnrs)
    procedure: (asin num) 
    procedure: (acos num) 
    returns: the arc sine or the arc cosine of num 
    libraries: (rnrs base), (rnrs)
    procedure: (atan num) 
    procedure: (atan real1 real2) 
    returns: see below 
    libraries: (rnrs base), (rnrs)
*** procedure: (bitwise-not exint) 
    returns: the bitwise not of exint 
    procedure: (bitwise-and exint ...) 
    returns: the bitwise and of exint ... 
    procedure: (bitwise-ior exint ...) 
    returns: the bitwise inclusive or of exint ... 
    procedure: (bitwise-xor exint ...) 
    returns: the bitwise exclusive or of exint ... 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-if exint1 exint2 exint3) 
    returns: the bitwise "if" of its arguments 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-bit-count exint) 
    returns: see below 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-length exint) 
    returns: see below 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    procedure: (bitwise-first-bit-set exint) 
    returns: the index of the least significant bit set in exint 
    libraries: (rnrs arithmetic bitwise), (rnrs)
    ...

    #+BEGIN_SRC scheme
    (define bitwise-if
      (lambda (exint1 exint2 exint3)
        (bitwise-ior
          (bitwise-and exint1 exint2)
          (bitwise-and (bitwise-not exint1) exint3))))
    #+END_SRC
*** procedure: (string->number string) 
    procedure: (string->number string radix) 
    returns: the number represented by string, or #f 
    libraries: (rnrs base), (rnrs)
    procedure: (number->string num) 
    procedure: (number->string num radix) 
    procedure: (number->string num radix precision) 
    returns: an external representation of num as a string 
    libraries: (rnrs base), (rnrs)
** 6.5.Fixnums
   Fixnums表示fixnum范围内的精确整数，它必须是一个闭合范围[-2w-1,2w-1 - 1]，其中w（fixnum宽度）至少为24.
*** procedure: (fixnum? obj) 
    returns: #t if obj is a fixnum, #f otherwise
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (least-fixnum) 
    returns: the least (most negative) fixnum supported by the implementation 
*** procedure: (greatest-fixnum) 
    returns: the greatest (most positive) fixnum supported by the implementation 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fixnum-width) 
    returns: the implementation-dependent fixnum width 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx=? fx1 fx2 fx3 ...) 
    procedure: (fx<? fx1 fx2 fx3 ...) 
    procedure: (fx>? fx1 fx2 fx3 ...) 
    procedure: (fx<=? fx1 fx2 fx3 ...) 
    procedure: (fx>=? fx1 fx2 fx3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxzero? fx) 
    returns: #t if fx is zero, #f otherwise 
    procedure: (fxpositive? fx) 
    returns: #t if fx is greater than zero, #f otherwise 
    procedure: (fxnegative? fx) 
    returns: #t if fx is less than zero, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxeven? fx) 
    returns: #t if fx is even, #f otherwise 
    procedure: (fxodd? fx) 
    returns: #t if fx is odd, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxmin fx1 fx2 ...) 
    returns: the minimum of fx1 fx2 ... 
    procedure: (fxmax fx1 fx2 ...) 
    returns: the maximum of fx1 fx2 ...
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx+ fx1 fx2) 
    returns: the sum of fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx- fx) 
    returns: the additive inverse of fx 
    procedure: (fx- fx1 fx2) 
    returns: the difference between fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx* fx1 fx2) 
    returns: the product of fx1 and fx2 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxdiv fx1 fx2) 
    procedure: (fxmod fx1 fx2) 
    procedure: (fxdiv-and-mod fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxdiv0 fx1 fx2) 
    procedure: (fxmod0 fx1 fx2) 
    procedure: (fxdiv0-and-mod0 fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fx+/carry fx1 fx2 fx3) 
    procedure: (fx-/carry fx1 fx2 fx3) 
    procedure: (fx*/carry fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxnot fx) 
    returns: the bitwise not of fx 
    procedure: (fxand fx ...) 
    returns: the bitwise and of fx ... 
    procedure: (fxior fx ...) 
    returns: the bitwise inclusive or of fx ... 
    procedure: (fxxor fx ...) 
    returns: the bitwise exclusive or of fx ... 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxif fx1 fx2 fx3) 
    returns: the bitwise "if" of its arguments 
    libraries: (rnrs arithmetic fixnums), (rnrs)
    #+BEGIN_SRC scheme
    (define fxif
      (lambda (fx1 fx2 fx3)
        (fxior (fxand fx1 fx2)
               (fxand (fxnot fx1) fx3))))
    #+END_SRC
*** procedure: (fxbit-count fx) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxlength fx) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxfirst-bit-set fx) 
    returns: the index of the least significant bit set in fx 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxbit-set? fx1 fx2) 
    returns: #t if bit fx2 of fx1 is set, #f otherwise 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxcopy-bit fx1 fx2 fx3) 
    returns: fx1 with bit fx2 replaced by fx3 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxbit-field fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxcopy-bit-field fx1 fx2 fx3 fx4) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxarithmetic-shift-right fx1 fx2) 
    returns: fx1 arithmetically shifted right by fx2 bits 
    procedure: (fxarithmetic-shift-left fx1 fx2) 
    returns: fx1 shifted left by fx2 bits 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxarithmetic-shift fx1 fx2) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxrotate-bit-field fx1 fx2 fx3 fx4) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)
*** procedure: (fxreverse-bit-field fx1 fx2 fx3) 
    returns: see below 
    libraries: (rnrs arithmetic fixnums), (rnrs)

** 6.6.Flonums

*** procedure: (flonum? obj) 
    returns: #t if obj is a flonum, otherwise #f 
    libraries: (rnrs arithmetic flonums), (rnrs)

*** procedure: (fl=? fl1 fl2 fl3 ...) 
    procedure: (fl<? fl1 fl2 fl3 ...) 
    procedure: (fl>? fl1 fl2 fl3 ...) 
    procedure: (fl<=? fl1 fl2 fl3 ...) 
    procedure: (fl>=? fl1 fl2 fl3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs arithmetic flonums), (rnrs)
*** MORE procedures
    ...
** 6.7.Characters
   字符是表示字母，数字，特殊符号（如$或 - ）和某些非图形控制字符（如空格和换行符）的原子对象。
   字符使用＃\前缀编写。 #\a #\b
   字符换行符，空格和制表符也可以这种方式编写，但它们可以更清晰地编写为＃\ newline，＃\ space和＃\ tab。
   任何Unicode字符都可以用＃\ xn语法编写，
*** procedure: (char=? char1 char2 char3 ...) 
    procedure: (char<? char1 char2 char3 ...) 
    procedure: (char>? char1 char2 char3 ...) 
    procedure: (char<=? char1 char2 char3 ...) 
    procedure: (char>=? char1 char2 char3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (char->integer char) 
    returns: the Unicode scalar value of char as an exact integer 
    libraries: (rnrs base), (rnrs)

    (char->integer #\newline) ;; 10
    (char->integer #\space) ;; 32
    (- (char->integer #\Z) (char->integer #\A)) ;; 25
    
    procedure: (integer->char n) 
    returns: the character corresponding to the Unicode scalar value n 
    libraries: (rnrs base), (rnrs)
    
    n must be an exact integer and a valid Unicode scalar value, i.e., ;; or ;;.

    (integer->char 48) ;; #\0
    (integer->char #x3BB) ;; #\;;
** 6.8.Strings
   字符串是字符序列，通常用作消息，字符缓冲区或文本块的容器。
   Scheme提供了创建字符串，从字符串中提取字符，获取子字符串，连接字符串以及更改字符串内容的操作。
   字符串包含在双引号中，"this is string"
   字符串中包含双引号的话，内部的双引号采用 \"; "this is string include \" double quotes \""
   可以使用其他双字符序列插入各种特殊字符，例如\ n表示换行符，\ r表示回车符，\ t表示制表符。 "line1\nline2"
*** procedure: (string=? string1 string2 string3 ...) 
    procedure: (string<? string1 string2 string3 ...) 
    procedure: (string>? string1 string2 string3 ...) 
    procedure: (string<=? string1 string2 string3 ...) 
    procedure: (string>=? string1 string2 string3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-ci=? string1 string2 string3 ...) 
    procedure: (string-ci<? string1 string2 string3 ...) 
    procedure: (string-ci>? string1 string2 string3 ...) 
    procedure: (string-ci<=? string1 string2 string3 ...) 
    procedure: (string-ci>=? string1 string2 string3 ...) 
    returns: #t if the relation holds, #f otherwise 
    libraries: (rnrs unicode), (rnrs)

    *case-insensitive*
*** procedure: (string char ...) 
    returns: a string containing the characters char ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-string n) 
    procedure: (make-string n char) 
    returns: a string of length n 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-length string) 
    returns: the number of characters in string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-ref string n) 
    returns: the nth character (zero-based) of string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-set! string n char) 
    returns: unspecified 
    libraries: (rnrs mutable-strings)
*** procedure: (string-copy string) 
    returns: a new copy of string 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-append string ...) 
    returns: a new string formed by concatenating the strings string ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (substring string start end) 
    returns: a copy of string from start (inclusive) to end (exclusive) 
    libraries: (rnrs base), (rnrs)
*** procedure: (string-fill! string char) 
    returns: unspecified 
    libraries: (rnrs mutable-strings)
*** procedure: (string-upcase string) 
    returns: the upper-case equivalent of string 
    procedure: (string-downcase string) 
    returns: the lower-case equivalent of string 
    procedure: (string-foldcase string) 
    returns: the case-folded equivalent of string 
    procedure: (string-titlecase string) 
    returns: the title-case equivalent of string 
    libraries: (rnrs unicode), (rnrs)
*** procedure: (string-normalize-nfd string) 
    returns: the Unicode normalized form D of string 
    procedure: (string-normalize-nfkd string) 
    returns: the Unicode normalized form KD of string 
    procedure: (string-normalize-nfc string) 
    returns: the Unicode normalized form C of string 
    procedure: (string-normalize-nfkc string) 
    returns: the Unicode normalized form KC of string 
    libraries: (rnrs unicode), (rnrs)
*** procedure: (string->list string) 
    returns: a list of the characters in string 
    libraries: (rnrs base), (rnrs)
*** procedure: (list->string list) 
    returns: a string of the characters in list 
    libraries: (rnrs base), (rnrs)
** 6.9.Vectors
   对于某些应用程序，向量比列表更方便和有效。
   Vectors的随机访问时常量复杂度O1，列表的随机访问时线性复杂度On
   Vectors打印形式： #(obj0 obj1 obj2 ...)

*** procedure: (vector obj ...) 
    returns: a vector of the objects obj ... 
    libraries: (rnrs base), (rnrs)
*** procedure: (make-vector n) 
    procedure: (make-vector n obj) 
    returns: a vector of length n 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-length vector) 
    returns: the number of elements in vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-ref vector n) 
    returns: the nth element (zero-based) of vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-set! vector n obj) 
    returns: unspecified 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-fill! vector obj) 
    returns: unspecified 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector->list vector) 
    returns: a list of the elements of vector 
    libraries: (rnrs base), (rnrs)
*** procedure: (list->vector list)
    returns: a vector of the elements of list 
    libraries: (rnrs base), (rnrs)
*** procedure: (vector-sort predicate vector)
    returns: a vector containing the elements of vector, sorted according to predicate 
    procedure: (vector-sort! predicate vector) 
    returns: unspecified 
    libraries: (rnrs sorting), (rnrs)
** 6.10.ByteVectors
   Bytevectors是原始二进制数据的向量。
   bytevector的长度是它存储的8位字节的数量，而bytevector中的索引总是作为字节偏移量给出。
** 6.11.Symbols
   符号
   字符串可以用于大多数相同的目的，但符号的一个重要特征使得符号之间的比较更加有效。
   (eq? 'aaa 'aaa) ;; #t
   (eq? "aaa" "aaa") ;; #f
   原因是Scheme读取器（由get-datum和read调用）和过程string-> symbol目录符号在内部符号表中，
   并且每当遇到相同的名称时始终返回相同的符号。避免逐个字符比较
   应用：
   - 程序表示中的标识符
   - 符号可以用作过程之间传递的消息
   - 列表结构记录的标签，
   - 存储在关联列表中的对象的名称
*** procedure: (symbol=? symbol1 symbol2) 
    returns: #t if the two symbols are the same, #f otherwise 
    libraries: (rnrs base), (rnrs)
*** procedure: (string->symbol string) 
    returns: a symbol whose name is string 
    libraries: (rnrs base), (rnrs)
*** procedure: (symbol->string symbol) 
    returns: a string, the name of symbol 
    libraries: (rnrs base), (rnrs)
** 6.12.Booleans
*** procedure: (boolean=? boolean1 boolean2)
    returns: #t if the two booleans are the same, #f otherwise 
    libraries: (rnrs base), (rnrs)

    boolean=? #t #t) <graphic> #t
    (boolean=? #t #f) <graphic> #f
    (boolean=? #t (< 3 4)) <graphic> #t
** 6.13.Hashtables
   Hashtables表示任意Scheme值之间的关联集。
   但是当涉及大量关联时通常要快得多。

*** procedure: (make-eq-hashtable) 
    procedure: (make-eq-hashtable size) 
    returns: a new mutable eq hashtable 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (make-eqv-hashtable) 
    procedure: (make-eqv-hashtable size) 
    returns: a new mutable eqv hashtable 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (make-hashtable hash equiv?) 
    procedure: (make-hashtable hash equiv? size) 
    returns: a new mutable hashtable 
    libraries: (rnrs hashtables), (rnrs)
    
    (define ht (make-hashtable string-hash string=?))

*** procedure: (hashtable-mutable? hashtable) 
    returns: #t if hashtable is mutable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-hash-function hashtable) 
    returns: the hash function associated with hashtable 
    procedure: (hashtable-equivalence-function hashtable) 

*** procedure: (equal-hash obj) 
    procedure: (string-hash string) 
    procedure: (string-ci-hash string) 
    procedure: (symbol-hash symbol) 
    returns: an exact nonnegative integer hash value 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-set! hashtable key obj) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-ref hashtable key default) 
    returns: see below 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-contains? hashtable key)
    returns: #t if an association for key exists in hashtable, #f otherwise 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-update! hashtable key procedure default) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-delete! hashtable key) 
    returns: unspecified 
    libraries: (rnrs hashtables), (rnrs)

*** procedure: (hashtable-size hashtable)
    returns: number of entries in hashtable 
    libraries: (rnrs hashtables), (rnrs)
*** More procedures
    ...
** 6.14.Enumerations
   枚举是有序的符号集，通常用于命名和操作选项，
   与创建文件时可能指定的缓冲区模式和文件选项一样。
*** syntax: (define-enumeration name (symbol ...) constructor) 
    libraries: (rnrs enums), (rnrs)

    - name 用于验证symble是否为枚举中的symble
      如果symble是枚举值，则返回该symble，否则抛出异常；
    - constructor 可用于创建枚举类型的子集。
      (construct x...)如果x...是name对应枚举的子集，则OK，否则句法违规
    
*** procedure: (make-enumeration symbol-list) 
    returns: an enumeration set 
    libraries: (rnrs enums), (rnrs)

    根据列表结合创建 枚举集合
*** procedure: (enum-set-constructor enum-set)
    returns: an enumeration-set construction procedure 
    libraries: (rnrs enums), (rnrs)

    根据枚举集合创建 枚举构造器
*** procedure: (enum-set-universe enum-set) 
    returns: the universe of enum-set, as an enumeration set 
    libraries: (rnrs enums), (rnrs)

    获取所有枚举项

*** procedure: (enum-set->list enum-set) 
    returns: a list of the elements of enum-set 
    libraries: (rnrs enums), (rnrs)
    
    将枚举集合转换为列表；

*** procedure: (enum-set-subset? enum-set1 enum-set2) 
    returns: #t if enum-set1 is a subset of enum-set2, #f otherwise 
    libraries: (rnrs enums), (rnrs)
    判断set1 是否为 set2的子集

*** procedure: (enum-set=? enum-set1 enum-set2)
    returns: #t if enum-set1 and enum-set2 are equivalent, #f otherwise 
    libraries: (rnrs enums), (rnrs)
    判断子集是否相等
    
    
*** procedure: (enum-set-member? symbol enum-set) 
    returns: #t if symbol is an element of enum-set, #f otherwise 
    libraries: (rnrs enums), (rnrs)

    判断 symbol 是否为 enum-set的成员

*** procedure: (enum-set-union enum-set1 enum-set2) 
    returns: the union of enum-set1 and enum-set2 
    并集
    procedure: (enum-set-intersection enum-set1 enum-set2) 
    returns: the intersection of enum-set1 and enum-set2 
    交集
    procedure: (enum-set-difference enum-set1 enum-set2) 
    returns: the difference of enum-set1 and enum-set2 
    libraries: (rnrs enums), (rnrs)
    差集

*** procedure: (enum-set-complement enum-set) 
    returns: the complement of enum-set relative to its universe 
    libraries: (rnrs enums), (rnrs)

    获取与超级的差集
    
*** procedure: (enum-set-projection enum-set1 enum-set2) 
    returns: the projection of enum-set1 into the universe of enum-set2 
    libraries: (rnrs enums), (rnrs)

    枚举set1的任何元素都不在enum-set2的Universe中。结果与enum-set2具有相同的枚举类型。
    公共超集的最大子集
    
*** procedure: (enum-set-indexer enum-set) 
    returns: a procedure that returns the index of a symbol in the universe of enum-set 
    libraries: (rnrs enums), (rnrs)
    
    获取一个记录枚举集合下标的过程，用于计算枚举项的下标值；
* 7. Input and Output(I/O)
  所有输入和输出操作都通过端口(port)执行。
  端口是指向（可能是无限的）数据流（通常是文件）的指针，程序可以从流中抽取字节或字符或将字节或字符放入流中的开口。
  端口可以​​是输入端口，输出端口或两者同时。
  Ports是一等对象，就像Scheme中的任何其他对象一样。
  与过程类似，端口没有字符串和数字的打印表示。
  最初有三个端口：当前输入端口，当前输出端口和当前错误端口，它们是连接到进程标准输入，标准输出和标准错误流的文本端口。
  提供了几种打开新端口的方法。
  
  输入端口通常指向有限流，如存储在磁盘上的输入文件。
  如果其中一个输入操作（例如get-u8，get-char或get-datum）被要求从已到达有限流末尾的端口读取，则返回一个特殊的eof（文件结束）对象。
  谓词eof-object？可用于确定从输入操作返回的值是否是eof对象。

  端口是二进制(binary)或文本(textual)。
  二进制端口允许程序从底层流中读取或写入8位无符号字节或“八位字节”。
  文本端口允许程序读取或写入字符。

  在许多情况下，底层流被组织为一个字节序列，但这些字节应被视为字符的编码。
  在这种情况下，可以使用代码转换器创建文本端口，以将字节解码为字符（用于输入）或将字符编码为字节（用于输出）。

  代码转换器封装了一个编解码器，用于确定字符如何表示为字节。
  提供了三种标准编解码器：latin-1编解码器，Unicode utf-8编解码器和Unicode utf-16编解码器。
  - 对于latin-1编码，每个字符仅由一个字节表示。
  - 对于utf-8，每个字符由一到四个字节表示，
  - 对于utf-16，每个字符由二到四个字节表示，
  
  转码器还封装了一个eol样式，用于确定是否以及如何识别行结尾。
  如果eol样式为none，则不会识别行结尾。其他六种标准eol样式如下：
  lf：换行符
  cr：回车符
  nel：Unicode下一行字符
  ls：Unicode行分隔符
  crlf：回车后跟换行
  crnel：回车后跟下一行

  eol样式以不同方式影响输入和输出操作。
  对于输入，除了none之外的任何eol样式都会将每个行结束字符或双字符序列转换为单个换行符。
  对于输出，除了none之外的任何eol样式都会将换行符转换为与eol样式关联的特定单字符或双字符序列。
  在输入方向上，除了none之外的所有eol样式都是等效的，而在输出方向上，eol样式none和lf是等效的。

  除了编解码器和eol风格之外，转码器还封装了另外一条信息：
  一种错误处理模式，用于确定在发生解码或编码错误时发生的情况，
  即，如果字节序列无法转换为输入方向上带有封装编解码器的字符，
  或者字符无法转换为字节序列封装的编解码器在输出方向上。
  
  错误处理模式是忽略，异常或替换。
  如果忽略错误处理模式，则忽略有问题的字节序列或字符。
  如果异常错误处理模式，则会引发条件类型为i / o-decoding或i / o-encoding的异常;
  在输入方向上，端口位于字节序列之外
  如果错误处理模式为replace，则会生成替换字符或字符编码：
  在输入方向上，替换字符是U + FFFD，而在输出方向上，替换是utf-8和utf-16编解码器的U + FFFD编码或问号字符的编码（？）对于latin-1编解码器。
  
  可以缓冲端口以提高效率，消除每个字节或字符对操作系统的调用开销。
  支持三种标准缓冲模式：块(block)，行(line)和没有(none)。
  使用块缓冲，从流中提取输入，并以一些与实现相关的大小的块发送输出到流。
  使用行缓冲，缓冲是逐行或依赖于某些其他实现进行的。
  行缓冲通常仅与文本输出端口的块缓冲区别开来;
  二进制端口中没有行划分，并且可能在流可用时从流中抽取输入。
  如果没有缓冲模式，则不执行缓冲，因此输出会立即发送到流，并且仅在需要时输入输入。

  章的其余部分介绍了对代码转换器，文件端口，标准端口，字符串和字节向量端口，自定义端口，
  常规端口操作，输入操作，输出操作，便捷I / O，文件系统操作以及字节向量和字符串之间的转换的操作。

** 7.1.Transcoders(转码器)
   转码器封装了三个值：编解码器，eol样式和错误处理模式。
   本节介绍了在转码器上创建或操作的过程以及转码器封装的值。
*** procedure: (make-transcoder codec) 
    procedure: (make-transcoder codec eol-style) 
    procedure: (make-transcoder codec eol-style error-handling-mode) 
    returns: a transcoder encapsulating codec, eol-style, and error-handling-mode 
    libraries: (rnrs io ports), (rnrs)
    
    创建转码器
    codec latin-1,utf-8,utf-16
    eol-style must be a valid eol-style symbol (lf, cr, nel, ls, crlf, crnel, or none);
              它默认为平台的原生eol风格。
    error-handling-mode 错误处理模式必须是有效的错误处理模式符号（忽略，提升或替换），并且默认为替换。
*** procedure: (transcoder-codec transcoder) 
    returns: the codec encapsulated in transcoder 
    procedure: (transcoder-eol-style transcoder) 
    returns: the eol-style symbol encapsulated in transcoder 
    procedure: (transcoder-error-handling-mode transcoder) 
    returns: the error-handling-mode symbol encapsulated in transcoder 
    libraries: (rnrs io ports), (rnrs)

    获取转码器的编码器，换行模式，错误处理模式
*** procedure: (native-transcoder) 
    returns: the native transcoder 
    libraries: (rnrs io ports), (rnrs)

    本机代码转换器依赖于实现，可能因平台或语言环境而异。
*** procedure: (latin-1-codec) 
    returns: a codec for ISO 8859-1 (Latin 1) character encodings 
    procedure: (utf-8-codec) 
    returns: a codec for Unicode UTF-8 character encodings 
    procedure: (utf-16-codec) 
    returns: a codec for Unicode UTF-16 character encodings 
    libraries: (rnrs io ports), (rnrs)

    创建编码器
*** syntax: (eol-style symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
    检测行结束格式。
    (eol-style crlf) <graphic> crlf
    (eol-style lfcr) <graphic> syntax violation
*** procedure: (native-eol-style) 
    returns: the native eol style 
    libraries: (rnrs io ports), (rnrs)
*** syntax: (error-handling-mode symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
** 7.2.OpeningFiles(打开文件)
   每个文件打开操作都接受一个路径参数，该参数命名要打开的文件。
   它必须是一个字符串或一些其他依赖于实现的值来命名文件。
   
   一些文件打开过程接受可选选项，b-mode和?transcoder参数。
   options必须是在下面的file-options条目中描述的构成有效文件选项的符号上设置的枚举，并且默认为（file-options）的值。
   b-mode必须是下面缓冲模式条目中描述的有效缓冲模式，并且默认为block。
   ?transcoder必须是 transcoder或#f;
   如果它是代码转换器，则打开操作返回基础二进制文件的转码端口，而如果它是#f（默认值），则打开操作返回二进制端口
   本节中的过程创建的二进制端口支持port-position,set-port-position!！操作。
   
*** syntax: (file-options symbol ...)
    returns: a file-options enumeration set 
    libraries: (rnrs io ports), (rnrs)
    有三种标准文件选项：no-create，no-fail和no-truncate，它只影响创建输出（包括输入/​​输出）端口的文件打开操作。
    
    默认选项如果文件已存在，则引发条件类型i / o-file-already-exists的异常，
    如果文件尚不存在则创建该文件。
    如果包含no-fail选项，则如果文件已存在则不会引发异常;相反，文件被打开并截断为零长度。
    
*** syntax: (buffer-mode symbol) 
    returns: symbol 
    libraries: (rnrs io ports), (rnrs)
    
    必须是 block, line, or none. 

*** syntax: (buffer-mode? obj) 
    returns: #t if obj is a valid buffer mode, #f otherwise 
    libraries: (rnrs io ports), (rnrs)
    判断是否合法的模式

*** procedure: (open-file-input-port path) 
    procedure: (open-file-input-port path options) 
    procedure: (open-file-input-port path options b-mode) 
    procedure: (open-file-input-port path options b-mode ?transcoder) 
    returns: a new input port for the named file 
    libraries: (rnrs io ports), (rnrs)

    打开文件输入端口，读取文件
    
*** procedure: (open-file-output-port path) 
    procedure: (open-file-output-port path options) 
    procedure: (open-file-output-port path options b-mode) 
    procedure: (open-file-output-port path options b-mode ?transcoder) 

    打开文件输出端口，写入文件

*** procedure: (open-file-input/output-port path) 
    procedure: (open-file-input/output-port path options) 
    procedure: (open-file-input/output-port path options b-mode) 
    procedure: (open-file-input/output-port path options b-mode ?transcoder) 
    returns: a new input/output port for the named file 
    libraries: (rnrs io ports), (rnrs)

    打开文件读写端口；

** 7.3.Standard Ports
   本节中描述的过程返回附加到进程标准输入，标准输出和标准错误流的端口。
   
*** procedure: (current-input-port) 
    returns: the current input port 
    procedure: (current-output-port) 
    returns: the current output port 
    procedure: (current-error-port) 
    returns: the current error port 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)

    当前文本输入输出端口
    
*** procedure: (standard-input-port) 
    returns: a fresh binary input port connected to the standard input stream 
    procedure: (standard-output-port) 
    returns: a fresh binary output port connected to the standard output stream 
    procedure: (standard-error-port) 
    returns: a fresh binary output port connected to the standard error stream 
    libraries: (rnrs io ports), (rnrs)
    
    标准文本输入输出端口

** 7.4.String and Bytevector Ports
   本节中的过程允许将字节向量和字符串用作输入或输出流。
   
   
*** procedure: (open-bytevector-input-port bytevector) 
    procedure: (open-bytevector-input-port bytevector ?transcoder) 
    returns: a new input port that draws input from bytevector 
    libraries: (rnrs io ports), (rnrs)

    无需关闭bytevector端口;

*** procedure: (open-string-input-port string) 
    returns: a new textual input port that draws input from string 
    libraries: (rnrs io ports), (rnrs)

    无需关闭字符串端口;
    
*** procedure: (open-bytevector-output-port) 
    procedure: (open-bytevector-output-port ?transcoder) 
    returns: two values, a new output port and an extraction procedure 
    libraries: (rnrs io ports), (rnrs)

    返回多值-2个过程，一个操作，一个提取
*** procedure: (open-string-output-port) 
    returns: two values, a new textual output port and an extraction procedure 
    libraries: (rnrs io ports), (rnrs)

    返回多值-2个过程，一个操作，一个提取
*** procedure: (call-with-bytevector-output-port procedure) 
    procedure: (call-with-bytevector-output-port procedure ?transcoder) 
    returns: a bytevector containing the accumulated bytes 
    libraries: (rnrs io ports), (rnrs)
*** procedure: (call-with-string-output-port procedure) 
    returns: a string containing the accumulated characters 
    libraries: (rnrs io ports), (rnrs)

** 7.5.Opeing Custom Ports
*** procedure: (make-custom-binary-input-port id r! gp sp! close)
    returns: a new custom binary input port 
    procedure: (make-custom-binary-output-port id w! gp sp! close) 
    returns: a new custom binary output port 
    procedure: (make-custom-binary-input/output-port id r! w! gp sp! close) 
    returns: a new custom binary input/output port 
    libraries: (rnrs io ports), (rnrs)


    这些过程允许程序从任意字节流创建端口。 id必须是一个命名新端口的字符串;
    id 该名称仅用于提供信息，实现可以选择将其包含在自定义端口的打印语法（如果有）中。
    创建自定义二进制输入/输出端口的程序通常应提供gp和sp！程序。

    - r! (read procedure) 读取输入，支持get-u8,get-bytevector-n.
      它使用三个参数调用：bytevector，start和n。从向量的start处读取n个字节
      如果字节流在文件末尾，r！应该返回0。否则，它应该从流中读取至少一个且最多n个字节，
      将这些字节存储在从start开始的bytevector的连续位置，并以实数正整数形式返回实际读取的字节数。
    - w! (write procedure) 调用w!将输出发送到端口，
      它使用三个参数调用：bytevector，start和n。写入start后的n字节到端口。
    - gp (get position) 被调用来查询端口的位置。
      如果是#f，则端口不支持端口位置。
      (gp) ;; position
    - sp! (set port's position) 
      如果是#f，端口将不支持set-port-position！
      (sp! 1253) ;; 设置由标位置
    - close 被调用来关闭字节流。
      如果是#f，则在关闭新端口时不会采取任何操作来关闭字节流。
      (close) ;;#f 无操作，#t 进行必要操作

*** procedure: (make-custom-textual-input-port id r! gp sp! close) 
    returns: a new custom textual input port 
    procedure: (make-custom-textual-output-port id w! gp sp! close) 
    returns: a new custom textual output port 
    procedure: (make-custom-textual-input/output-port id r! w! gp sp! close) 
    returns: a new custom textual input/output port 
    libraries: (rnrs io ports), (rnrs)

** 7.6.Port Operations
   不涉及读/写操作
   
*** procedure: (port? obj) 
    returns: #t if obj is a port, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

    procedure: (input-port? obj) 
    returns: #t if obj is an input or input/output port, #f otherwise 
    procedure: (output-port? obj) 
    returns: #t if obj is an output or input/output port, #f otherwise 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)
    
    procedure: (binary-port? obj) 
    returns: #t if obj is a binary port, #f otherwise 
    procedure: (textual-port? obj) 
    returns: #t if obj is a textual port, #f otherwise 
    libraries: (rnrs io ports), (rnrs)
    
*** procedure: (close-port port)
    returns: unspecified 
    libraries: (rnrs io ports), (rnrs)
    
    应该手动调用close-port，不应该依赖于系统close。关闭已关闭的端口不会报错，只是忽略该操作。
    
*** procedure: (transcoded-port binary-port transcoder) 
    returns: a new textual port with the same byte stream as binary-port 
    libraries: (rnrs io ports), (rnrs)
    
    此过程返回一个带有代码转换器代码转换器的新文本端口，以及与二进制端口相同的基础字节流，位于二进制端口的当前位置。
    作为创建文本端口的副作用，二进制端口被关闭以防止二进制端口上的读取或写入操作干扰新文本端口上的读取和写入操作。
    然而，基础字节流保持打开状态，直到文本端口关闭。
    stream(open)-->binary-port(open)
    stream(open)-->binary-port(close) ;;防止干扰textual-port，被关闭
    stream(open)-->textual-port(open)
    stream(close)-->textual-port(close)

*** procedure: (port-transcoder port) 
    returns: the transcoder associated with port if any, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (port-position port) 
    returns: the port's current position 
    procedure: (port-has-port-position? port) 
    returns: #t if the port supports port-position, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (set-port-position! port pos) 
    returns: unspecified 
    procedure: (port-has-set-port-position!? port) 
    returns: #t if the port supports set-port-position!, #f otherwise 
    libraries: (rnrs io ports), (rnrs)

*** procedure: (call-with-port port procedure) 
    returns: the values returned by procedure 
    libraries: (rnrs io ports), (rnrs)
    
    call-with-port调用过程，将port作为唯一参数。
    如果procedure返回，call-with-port将关闭端口并返回procedure返回的值。
    如果在过程外创建的 *延续被调用* ，call-with-port不会自动关闭端口，
    因为有可能在稍后的时间调用在过程内创建的另一个继续，将控制返回到过程。
    如果过程没有返回，则只有在可以证明输出端口不再可访问的情况下，实现才可以自由关闭端口。
    
    下面的示例将infile的内容复制到outfile，如果存在则覆盖outfile。
    除非发生错误，否则在复制完成后将关闭端口。

    #+BEGIN_SRC scheme
    (call-with-port (open-file-input-port "infile" (file-options)
                      (buffer-mode block) (native-transcoder))
      (lambda (ip)
        (call-with-port (open-file-output-port "outfile"
                          (file-options no-fail)
                          (buffer-mode block)
                          (native-transcoder)) 
          (lambda (op)
            (do ([c (get-char ip) (get-char ip)])
                ((eof-object? c))
              (put-char op c))))))
    #+END_SRC

*** procedure: (output-port-buffer-mode port) 
    returns: the symbol representing the buffer mode of port 
    libraries: (rnrs io ports), (rnrs)

** 7.7.Input Operations
   本节描述了主要目的是从输入端口读取数据的过程，以及用于识别或创建文件结束（eof）对象的相关过程。
   
*** procedure: (eof-object? obj) 
    returns: #t if obj is an eof object, #f otherwise 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)

    当输入端口到达输入结束时，输入操作（例如，get-datum）返回文件结束对象。

*** procedure: (eof-object) 
    returns: the eof object 
    libraries: (rnrs io ports), (rnrs io simple), (rnrs)
    #+BEGIN_SRC scheme
    (eof-object? (eof-object)) ;; #t
    #+END_SRC
    
*** procedure: (get-u8 binary-input-port) 
    returns: the next byte from binary-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)
    
    读取一个无符号字节(0~255),游标+1
    或读取到eof
    #+BEGIN_SRC scheme
    (let* ((vec-num (vector 0 1 2 3 4 5 6 7 8 9))
           [vec-reader (open-bytevector-input-port vec-num)])
      (display 'hello))

    #+END_SRC

*** procedure: (lookahead-u8 binary-input-port) 
    returns: the next byte from binary-input-port, or the eof object 
    libraries: (rnrs io ports), (rnrs)