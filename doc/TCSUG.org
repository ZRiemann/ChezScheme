#+TITLE Chez Scheme Version 9 User's Guide Learning Notes(中文)
* 前言
  Chez Scheme 用户手册学习笔记。
* 1.引言
  Chez Scheme V9 完全实现R6RS，以及一系列扩展;编译器通过额外增加编译时间，做到
更快代码。这是The Scheme Programming Language(TSPL4)的扩展。TSPLS4只写R6RS标准
接口，TCSUG 描述了Chez Scheme扩展（工业项目实施的基础）。 <br/>
  第二章 *程序开发、脚本、发布、生成有效代码* <br/>
  第三章 *调试及对象检查工具* <br/>
  第四章 *分离的过程文档工具(document facilities for ...)* <br/>
  第五章 *绑定形式(binding forms)* <br/>
  第六章 *控制结构* <br/>
  第七章 *操作非数值对象(nonnumeric objects)* <br/>
  第八章 *高效数值操作* <br/>
  第九章 *IO操作及通用端口* <br/>
  第十章 *R6RS库及控制、跟踪接口* <br/>
  第十一章 *语法扩展及模块* <br/>
  第十二章 *定制交互及用户接口* <br/>
  第十三章 *存储管理系统控制* <br/>
  第十四章 *定制表达式编辑器* <br/>
  第十五章 *本地线程系统及句法* <br/>
  第十六章 *各种兼容特征* <br/>
  结尾     *参考文献(bibliography) 形式摘要(summary of forms)和索引*
** 1.语法(Chez Scheme Syntax)
   CS 扩展了Scheme的对象和语法形式。
   - *语法扩展*
     0abc,+++,..,{,} 是合法的标识
     \或|逃逸打印, \||\| -> \|
     |hit me!| 带空格标识
     #36rZZ is 35 X 36 + 35, or 1295
     #\000 is equivalent to #\nul.
     #\alarm, #\backspace, #\delete, #\esc, #\linefeed, #\newline
     #\page, #\return, #\space, and #\tab #\bel, #\ls, #\nel, #\nul
     #\rubout, and #\vt (or #\vtab)
     #3(a b c) #100(0)一百空间的向量
     #&17 box(int 17)
     #% $primitive form; %2%car == $primitve 2 car
     #!eof end-of-file object, 插在文件中间阻止加载后续内容
     #!bwb broken weak pointer object
   - *词汇扩展(lexical extensions)*
     #!r6rs
     #!chezscheme
     import RNSR --program
     scheme-script
     load-program
     #!fold-case string-foldcase
     #!no-fold-case
     #f case-senstitive
     write, put-datum, pretty-print, and the format ~s
     print-extended-identifiers
     print-vector-length
** 2.符号约定(Notational Conventitions)
   unspecified 返回任意类型值
   通常返回 void 对象
   must 必须如此，否则异常
   should 因该如此，否则结果不确定
   &sssertion
   &syntax 违反语法规定
** 3.参数(Parameters)
** 4.More Information
* 2.Using Chez Scheme
** 1.Interacting with ChezScheme(交互式Scheme)
   最有效的编程方式是使用vi 或 emacs，使用Chez Schem 在shell中进行调试。
默认安装后在shell下输入命令 *scheme* 即可开始交互式Scheme会话，输入命令 *petite*
开始 Petite Chez Scheme。 "REPL" 代表 "Read(读)-Eval(求值)-Print(打印)-LOOP
(循环 )"

[zriemann7@localhost doc]$ scheme
Chez Scheme Version 9.5.1
Copyright 1984-2017 Cisco Systems, Inc.

> (cons 'a '(b c d))
(a b c d)
> 

 - 如何退出交互程序 ： *CTL-d* *(exit)*
 - 终止程序进入debug模式： *CTL-c*
   break> ["e"|"r"|"a"|"n"|"i"|"s"|"?"]

使用 --script --program 命令行选项，debug-on-exception --debug-on-exception
Chez Scheme 传统扩展名 *.ss* 也可以是任意的或无扩展名。
*(load "source/code/path.ss") 加载源文件*
*(compile-file "source/code/path.ss") 编译源文件得到path.so*
加载预编译文件本质上和加载源文件相同，但加载 *path.so* 更快。

*echo '(compile-file "path/file.ss")' | scheme -q*
*echo '(reset-handler abort) (compile-file "path/file.ss")' | scheme -q*
** 2.Expression Editor(表达式编辑器)
   介绍编辑器快捷键
** 3.The Interaction Environment(交互环境)
   RNRS 标识符只能被定义一次，Interaction 可以定义多次；
*chezcheme* *scheme* *RNRS* 库；
引入rnrs库:
#+BEGIN_SRC scheme
(import
 (rnrs)
 (rnrs eval)
 (rnrs mutable-pairs)
 (rnrs mutable-strings)
 (rnrs r5rs))
#+END_SRC
交互环境引入rnrs库:
#+BEGIN_SRC scheme
(interaction-environment
 (copy-environment
  (environment
   '(rnrs)
   '(rnrs eval)
   '(rnrs mutable-pairs)
   '(rnrs mutable-strings)
   '(rnrs r5rs))
  #t))
#+END_SRC
包含 chezscheme 库 library import
#+BEGIN_SRC scheme
;; chezscheme library and import
(interaction-environment
 (copy-environment
  (environment
   '(rnrs)
   '(rnrs eval)
   '(rnrs mutable-pairs)
   '(rnrs mutable-strings)
   '(rnrs r5rs)
   '(only (chezscheme) library import))
  #t))
#+END_SRC
*内建变量只读，不能被赋值*
#+BEGIN_SRC scheme
;;Exception: attempt to assign immutable variable cons
(set! cons +)

;; redefines cons to count the number of times it is called
;; 重定义 cons
(define cons-count 0)
(define original-cons cons)
(define cons
  (lambda (x y)
    (set! cons-count (+ cons-count 1))
    (original-cons x y)))
;; assigns cons to its original value
;; 还原 cons
(set! cons original-cons)
;; 还原 cons +1
(import (only (chezscheme) cons))
;; 
(define cons (let () (import scheme) cons))

;;
(library (A) (export a)
         (import (rnrs))
         (define-syntax a
           (lambda (x)
             (syntax-case x ()
               [(_ id) (free-identifier=? #'id #'undefined)]))))
(let () (import (A)) (a undefined))

;;
(library (A) (export a aux-a)
         (import (rnrs) (only (chezscheme) syntax-error))
         (define-syntax aux-a
           (lambda (x)
             (syntax-error x "invalid context")))
         (define-syntax a
           (lambda (x)
             (syntax-case x (aux-a)
               [(_ aux-a) #''okay]
               [(_ _) #''oops]))))
;; okay
(let () (import (A)) (a aux-a))
;; oops
(let () (import (only (A) a)) (a aux-a))
#+END_SRC
** 4.Using Libraries and Top-Level Programs(库与顶层程序)
*** summary
   *load/load-library* 显式加载 *重定义* 已定义的库
   *import* 隐式加载 *不重载* 已定义的库，库文件必须位于同目录下；
   *library-directories* 库搜索路径
   *library-extensions* 扩展库参数
   *source-directires*
   如：基础库目录/usr/lib/scheme, 库名称(app lib1) 和扩展 *.sls*
   则全路径为 /usr/lib/scheme/app/lib1.sls
   扩展器(expander)优先加载最新的对象文件
   *compile-imported-libraries*
   *compile-file(#!chezscheme)/compile-library(隐含#!r6rs)*
   *import-notify #t* 可以通过将参数import-notify设置为#t来监视扩展器在处理尚未加载的库的导入时使用的搜索过程。
   *echo '(compile-library "filename")' | scheme -q*

   *load-program(self-contained效率更高) | load(顶层域)* 加载程序
   *compile-program*
   *echo '(compile-program "filename")' | scheme -q*
   *revisit*
*** R6RS library
    - 可直接在REPL中定义（允许redefine）
    - 使用 *load-library,load* 显式直接从文件导入,（允许redefine）
    - 使用 *import* 瘾式从文件导入，不允许重新载入(reloads)
      (tool sorting) => <search-dirs>/tools/sorting.[so|ss|sls]
      + (library-directories) => <search-dirs>
        return: list of pairs of strings(返回字符串对)
        values: ((<source-file-base-dir> . <object-file-base-dir>) ...)
                (("." . ".") ("~/lib/scheme" . "~/lib/scheme"))
      + (library-extensions) => [so|ss|sls|...]
        return: list of pairs of stirngs
        values: ((<source-file-extension> . <object-file-extension) ...)
                (("ss" . "so") ("sls" . "so") ...)
    - 查找加载流程
      1. 例子
        (import (tools sorting))
        (library-directories) ;;=> /usr/lib/scheme/libraries, .
        (library-extensions)  ;;=> ss
         查找范围
         /usr/lib/scheme/libraries/tools/sorting.ss
         /usr/lib/scheme/libraries/tools/sorting.sls
         ./tools/sorting.ss
         ./tools/sorting.sls
      2. 构造部分名称, (tools sorting) ==> tools/sorting
      3. 在(library-directories)中查找对于的 <search-dir>/tools/sorting
      4. 尝试所有的扩展名 <search-dir>/tools/sorting.<extensions>
         #+BEGIN_SRC scheme
         (import-notify #t) ;; 设置搜索路径监视 --import-notify
         ;;; 库文件搜索逻辑
         (define search-import-library
           lambda (lib-name search-paths extensions)
           (define load-source-library
             lambda (source)
             (if (compile-imported-libraries)
                       (compile-library source)
                       load-sourcefile))
             )
           ;;; for-each paths
           (if (and find-search-path/lib-name.<src-ext> find-search-path/lib-name.<lib-ext>)
               ;;; 同时存在 source,object files
               (if (object-not-older)
                   (load-object-file object)
                   (load-source-library source)
               ;;; 只找到一个文件
                   (load-source-library source)
               )
           )
         #+END_SRC
    - *编译so文件* echo '(compile-library "filename")' | scheme -q
    - *(load-program "file")* 更高效
    - *(load "file")*
    - *revisit,load/visit*
    - scheme --libdirs "/home/mio/lib:"
      scheme --libdirs "/home/moi/libsrc::/home/moi/libobj:"
    - CHEZSCHEMELIBDIRS 环境变量

** 5.Scheme Shell Scripts(Scheme脚本)
   --script 制定是Scheme脚本
   参考 src/script/c2-command-line.sh
   *--libdirs* 
   $ scheme --libdirs "/home/mio/lib:"
   ("/home/mio/lib" . "/home/moi/lib")
   $ scheme --libdirs "/home/moi/libsrc::/home/moi/libobj:"
   ("/home/moi/libsrc" . "/home/moi/libobj")

   *--libexts*
#+BEGIN_SRC scheme
#! /usr/bin/scheme --script
;; 打印脚本参数
(for-each
 (lambda (x) (display x) (newline))
 (cdr (command-line)))
#+END_SRC
#+BEGIN_SRC scheme
#! /usr/bin/scheme --script
;; implements the triditional Unix echo command
;; 实现传统的 Unix echo 命令
(let ([args (cdr (command-line))])
  (unless (null? args)
          (let-values ([(newline? args)
                        (if (equal? (car args) "-n")
                            (values #f (cdr args))
                            (values #t args))])
            (do ([args args (cdr args)] [sep "" " "])
                ((null? args))
              (printf "~a~a" sep (car args)))
            (when newline? (newline)))))
#+END_SRC
** 6.Optimization(优化)
   - avoid the use of top-level(interaction-environment) bindings.
     避免顶层绑定.
   - *compile-whole-program* 全程优化
   - *load-program* 使用 *compile-program/library* 不要使用 *compile-file*
   - 使用optimize-level 3 参数
     *(parameterize ([optimize-level 3]) (compile-program "filename"))*
     *echo '(compile-program "filename")' | scheme -q --optimize-level 3*
   - 使用fixnum 或 flonum 操作替代通用数值操作
   - 使用显式循环而不是嵌套线性表处理 (append/reverse/map)
   - 在生产代码中关闭"profiling"(分析器)，否则会分析代码会带来大量额外的运行时开销；
** 7.Customization(定制)
   Chez Scheme由多个子系统组成：
   - *kernel* 封装系统接口，加载引导或堆文件，启动交互会话，启动脚本，释放系统
   - *petite.boot/scheme.boot* 包含编译器的运行时库
** 8.Building and Distribution Applications(构建和发布应用程序)
   Petite Chez Scheme *Characteristics(特性)*.
   - *Preparing Application Code.*
     + 发布编译后的代码优势
       1. *效率高* 首先，编译代码通常效率更高
       2. *避免被破解* 编译代码是二进制形式，因此为专有应用程序代码提供了更多保护。
   *(generate-inspector-information #f)* 生产代码，关闭检测
   *(strip-fasl-file)* 删除调试信息,作为(generate-inspactor-information #f)的替代方案
   #+BEGIN_SRC scheme
   (scheme-start
    (lambda fns
      (for-each
       (lambda (fn)
         (printf "loading ~a ..." fn)
         (load fn)
         (printf "~%"))
       fns)
      (new-cafe)))
   #+END_SRC
   #+BEGIN_SRC scheme
   ;; windows 下加载state.dll 的show_state接口
   (define show-state)
   (define app-init
     (lambda ()
       (load-shared-object "state.dll")
       (set! show-state
             (foreign-procedure "show_state" (integer-32)
                                integer-32))))
   (scheme-start
    (lambda fns
      (app-init)
      (app-run fns)))
   #+END_SRC
*** Building and Running the Application
   通过cat / copy 命令将多个对象文件组成一个文件
   对于具有单独库的顶级程序，可以使用compile-whole-program生成单个完全优化的目标文件。
   否则，在连接目标文件时，将每个库放在它所依赖的库之后，程序最后。
   compile-whole-program 
   
   scheme appl.so
   > ((scheme-start)) ;; 产生 boot file
   
   - boot file 相比 object file 优点
     1. 压缩为运行时静态运行时库，存储管理器永远不会收集静态代码和数据，所以垃圾收集开销减少了。
        也可以使用(collect ...)使代码、数据静态化
     2. 系统根据可执行映像的名称在一组标准目录中自动查找启动文件，
        因此，您可以在应用程序名称下安装Petite Chez Scheme可执行映像的副本，
        并使您的用户免于提供任何命令行参数或运行单独的脚本来加载应用程序代码。
   - boot file 是目标文件，可能包含多个源文件的代码，前缀为boot header。
     boot header: 标识依赖，备选运行方案；
     petite.boot是基本启动文件
     加载应用程序引导文件时，将自动加载基本引导文件及其基本引导文件（如果有）。
   - boot file 创建, (make-boot-file "<user-name>.boot" <list-of-stirng> <stirng-naming-input-files>)
     (make-boot-file "app.boot" '("petite") "app1.so" "app2.ss" "app3.so")
     (make-boot-file "app.boot" '("scheme" "petite") "app.so")
                                 优先加载scheme.boot
*** Distributing the Application.
    分发应用程序涉及的可以像创建包含以下项目的分发包一样简单：
    - Petite Chez Scheme发布包
    - application boot file
    - any application-specific shared libraries
    - an application installation script. (用于安装scheme)
*** Sample Unix Installation Script.  
    The script below demonstrates how to perform a straightforward installation of a Scheme application on a Unix-based platform. The script makes the following assumptions, any of which may be changed by altering the script's application configuration parameters:

the name of the application to install is app,
the machine type upon which the installation will take place is i3le (Intel Linux),
a single shared library, libapp.so, is included in the distribution, and
a single application boot file, app.boot, is included in the distribution.
The script also sets the default location for executables to /usr/bin and shared libraries to /usr/lib. These settings would typically be open to change by the end user; a friendlier script would query the user to verify that these settings are appropriate.

The script first installs Petite Chez Scheme, then installs the boot file and shared libraries, then sets up the executable.

# installation directories
prefix=/usr
bin=${prefix}/bin
lib=${prefix}/lib 

# Petite Chez Scheme version information
machine=i3le
release=7.0 

# application configuration
app=app
libs=lib${app}.so
boot=${app}.boot 

# install Petite Chez Scheme
tar -xzf csv${release}-${machine}.tar.gz
(cd csv${release}/custom; ./configure --installprefix=${prefix})
(cd csv${release}/custom; make install) 

# install the boot file
cp ${boot} ${lib}/csv${release}/${machine}
chmod 444  

# install the shared libraries
cp ${libs} ${lib}
chmod 444 ${libs} 

# create a link for the executable
ln -s ${bin}/petite ${bin}/${app}

** 9.Command-Line Options
* 3.Debugging(调试)
** Tracing
   all libraries: (chezscheme)
   *(trace-lambda name formals body1 body2 ...)*
   returns:a traced procedure
#+BEGIN_SRC scheme
(define half
  (trace-lambda half-name (x)
                (cond
                 [(zero? x) 0]
                 [(odd? x) (half (- x 1))]
                 [(even? x) (+ (half (- x 1)) 1)])))
(half 5)

(trace)

(define x (inspect/object '(1 2 3)))
(x 'type)
(x 'length)
(define p (open-output-string))
(x 'write p)
(get-output-string p)

#+END_SRC
   *(trace-case-lambda name clause ...)*
   returns: a traced procedure 
   *(trace-let name ((var expr) ...) body1 body2 ...)*
   returns: the values of body body1 body2 ...
   *(trace-do ((var init update) ...) (test result ...) expr ...)*
   returns: the values of last result expression
   *(trace/untrace var1 var2 ...)*
   returns: a list of var1 var2
   *(trace/untrace)*
   return: a list of all currently traced top-level variables
   *trace-output-port thread parameter*
   *trace-print thread parameter*
   *(trace-define var expr)*
   *(trace-define (var . idspec) body1 body2 ...)*
   returns: unspecified
   *(trace-define-syntax keyword expr)*
** 2.The Interactive Debugger(交互调试器)
   all libraries:(chezscheme)
   *debug-on-exception #t*
   *(debug) procedure*
** 3.The Interactive Inspector(交互检查)
   *(inspect)   is-procedure*
   *(printf/p <obj>) using-pretty-print*
   *(write/w <obj>) using-write*
   *(size <obj>)*
   *(find expr [g])*
   *(find-next)*
   *(up/u)*
   *(top/t)*
   *(forward/f)*
   *(back/b)*
   *(=> <expr>)*
   *(file <path>)*
   *(mark/m)*
   *(goto/g)*
   *(new-cafe/n) enters a new read-eval-print loop(cafe)*
   *(quit/q)*
   *(reset/r)*
   *(abort/a <x>)*
   Continuation commands
   *(show-frames/sf)*
   *(depth)*
   *(down/d)*
   *(show/s)*
   *(show-local/sl)*
   *(length/l)*
   *(ref/r)*
   *(code/c)*
   *(file)*
   Procedure commands
   *(show/s)*
   *(code/c)*
   *(file)*
   *(length)*
   *(ref/r)*
   *(set!/! <n>)*
   *(eval/e <expr>)*
   Pair(list)commands
   *(show/s [n]) shows the first [n]/all elements of the list*
   *(length/l)*
   *(car)*
   *(cdr)*
   *(ref/r)*
   *(tail [n])*
   Vector,Bytevector,Fxvector commands
   *show/length/ref*
   String commands
   *show/length/ref/unicode/ascii*
   Symbol commands
   *show/value/name/property-list/ref*
   Charracter commands
   *unicode/ascii*
   Box commands
   *show/unbox/ref*
   Port commands
   *show/name/handler/output-buffer/input-buffer*
   Record commands
   *show/fields/name/rtd/ref/set!*
   Transport Link Cell(TLC) commands
   *show/keyval/tconc/next/ref*
** 4.The Object Inspector
   *(inspect/object <object>)  is-procedure*
   Pair inspector objects.
   *(<pair-object> 'type/'car/'cdr/'length)*
   Box/TLC/Vector/Simple/Unbond/Procedure/...
** 5.Locating objects
   *(make-object-finder pred [x] [g])  is-procedure*
** 6.Nested object size and compostion
* 4.Foreign Interface(外部接口)
  Chez Scheme 提供两种外部代码交互方式
  1. 通过子进程通信
  2. Scheme调用C动态或静态库，
     C调用Scheme动态或静态库
** 1.Subprocess Communication(子过程通信)
   Two procedures, *(system) and (precess)*, ARE used to create *subprocess*.
   *(system) (precess)* 用于创建子进程
   *(system <command-string>)  is-procedure* 同步等待，stdin/out与console通信
   *(precess <command-string>)  is-prcedure* 异步进行，stdin/out与Scheme通信
   *(open-process-ports command [b-mode] [?transcoder])*
** 2.Calling out of Scheme(外部调用Scheme)
   *(foreign-rpcedure entry-exp (param-type ...) ret-type)   is-syntax*
   *(foreign-procedure conv ecntry-exp (param-type ...) res-type)  is-syntax*
   returns: a procedure
   
C 接口
int id(int x){return x;}
Scheme 引入C接口
#+BEGIN_SRC scheme
(foreign-procedure "id" (int) int)
;; #<procedure
((foreign-procedure "id" (int) int) 1)
;; 1
(define int-id
  (foreign-procedure "id" (int) int))
(int-id 1)
;; 1

;; 可以改造成bool
(define bool-id
  (foreign-procedure "id" (boolean) boolean))
(bool-id #f)
;; #f
(bool-id 1)
;; #t
#+END_SRC
** 3.Calling into Scheme
   *(foreign-callable conv ... proc-exp (param-type ...) res-type)  is-syntax*
   return: a code object
   - proc-exp
     a procedure is to be invoked by foreign code.
** 4.Continuations and Foreign Calls
** 5.Foreign Data
   *(foreign-alloc)*
   *(foreign-free)*
   *(foreign-sizeof)*
   *(foreigh-ref type address offset)*
** 6.Providing Access to Foreign Procedures
** 7.Using Other Foreign Language
** 8.C Library Routines
** 9.Socket Operations
* 5.Binding Forms
  
   
   
* 函数表

|--------------+----------------------+---+---|
| load         | 现式(explicitly)加载 |   |   |
| load-library | 现式加载加载库       |   |   |
| import       | 隐式(implicitly)加载 |   |   |

* 生词表
Top-level bindings are *convenient and appropriate* during program development,
, since they simplify testing, redefinition, and tracing of *individual* proc-
edures and syntatic forms.
顶层绑定是 *方便和合适的* 在程序开发期间，因为他们简化了测试，重构，追踪单个过
程和句法形式。
While the kernel and base boot file *are essential to* the operation of all pr-
ograms,
内核和引导文件是启动程序的必须条件；
